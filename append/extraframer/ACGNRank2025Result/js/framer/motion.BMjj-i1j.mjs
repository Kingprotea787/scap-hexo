import { r as e, t } from './rolldown-runtime.BRwTesTf.mjs';
import {
  B as n,
  D as r,
  E as i,
  F as a,
  H as o,
  I as s,
  L as c,
  M as l,
  N as u,
  P as d,
  R as f,
  T as p,
  V as m,
  _ as h,
  b as g,
  c as _,
  d as v,
  f as y,
  j as b,
  l as x,
  o as S,
  s as ee,
  u as C,
  w as te,
  z as w,
} from './react.DPVtOLUT.mjs';
var ne,
  re,
  ie,
  ae,
  oe,
  se,
  ce,
  le,
  ue,
  de,
  fe,
  pe,
  me,
  he,
  ge,
  _e,
  ve,
  ye,
  be,
  xe,
  Se,
  Ce,
  we,
  Te,
  Ee,
  De,
  Oe,
  ke,
  Ae,
  je = t(() => {
    ((ne = Object.create),
      (re = Object.defineProperty),
      (ie = Object.getOwnPropertyDescriptor),
      (ae = Object.getOwnPropertyNames),
      (oe = Object.getPrototypeOf),
      (se = Object.prototype.hasOwnProperty),
      (ce = (e, t) => ((t = Symbol[e]) ? t : Symbol.for(`Symbol.` + e))),
      (le = (e) => {
        throw TypeError(e);
      }),
      (ue = (e, t, n) =>
        t in e
          ? re(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
          : (e[t] = n)),
      (de = (e, t) => re(e, `name`, { value: t, configurable: !0 })),
      (fe = ((t) =>
        e === void 0
          ? typeof Proxy < `u`
            ? new Proxy(t, { get: (t, n) => (e === void 0 ? t : e)[n] })
            : t
          : e)(function (t) {
        if (e !== void 0) return e.apply(this, arguments);
        throw Error(`Dynamic require of "` + t + `" is not supported`);
      })),
      (pe = (e, t) =>
        function () {
          return (t || (0, e[ae(e)[0]])((t = { exports: {} }).exports, t), t.exports);
        }),
      (me = (e, t) => {
        for (var n in t) re(e, n, { get: t[n], enumerable: !0 });
      }),
      (he = (e, t, n, r) => {
        if ((t && typeof t == `object`) || typeof t == `function`)
          for (let i of ae(t))
            !se.call(e, i) &&
              i !== n &&
              re(e, i, { get: () => t[i], enumerable: !(r = ie(t, i)) || r.enumerable });
        return e;
      }),
      (ge = (e, t, n) => (
        (n = e == null ? {} : ne(oe(e))),
        he(t || !e || !e.__esModule ? re(n, `default`, { value: e, enumerable: !0 }) : n, e)
      )),
      (_e = (e) => [, , , ne(e?.[ce(`metadata`)] ?? null)]),
      (ve = [`class`, `method`, `getter`, `setter`, `accessor`, `field`, `value`, `get`, `set`]),
      (ye = (e) => (e !== void 0 && typeof e != `function` ? le(`Function expected`) : e)),
      (be = (e, t, n, r, i) => ({
        kind: ve[e],
        name: t,
        metadata: r,
        addInitializer: (e) => (n._ ? le(`Already initialized`) : i.push(ye(e || null))),
      })),
      (xe = (e, t) => ue(t, ce(`metadata`), e[3])),
      (Se = (e, t, n, r) => {
        for (var i = 0, a = e[t >> 1], o = a && a.length; i < o; i++)
          t & 1 ? a[i].call(n) : (r = a[i].call(n, r));
        return r;
      }),
      (Ce = (e, t, n, r, i, a) => {
        var o,
          s,
          c,
          l,
          u,
          d = t & 7,
          f = !!(t & 8),
          p = !!(t & 16),
          m = d > 3 ? e.length + 1 : d ? (f ? 1 : 2) : 0,
          h = ve[d + 5],
          g = d > 3 && (e[m - 1] = []),
          _ = e[m] || (e[m] = []),
          v =
            d &&
            (!p && !f && (i = i.prototype),
            d < 5 &&
              (d > 3 || !p) &&
              ie(
                d < 4
                  ? i
                  : {
                      get [n]() {
                        return De(this, a);
                      },
                      set [n](e) {
                        return ke(this, a, e);
                      },
                    },
                n
              ));
        d ? p && d < 4 && de(a, (d > 2 ? `set ` : d > 1 ? `get ` : ``) + n) : de(i, n);
        for (var y = r.length - 1; y >= 0; y--)
          ((l = be(d, n, (c = {}), e[3], _)),
            d &&
              ((l.static = f),
              (l.private = p),
              (u = l.access = { has: p ? (e) => Ee(i, e) : (e) => n in e }),
              d ^ 3 &&
                (u.get = p ? (e) => (d ^ 1 ? De : Ae)(e, i, d ^ 4 ? a : v.get) : (e) => e[n]),
              d > 2 &&
                (u.set = p ? (e, t) => ke(e, i, t, d ^ 4 ? a : v.set) : (e, t) => (e[n] = t))),
            (s = (0, r[y])(
              d ? (d < 4 ? (p ? a : v[h]) : d > 4 ? void 0 : { get: v.get, set: v.set }) : i,
              l
            )),
            (c._ = 1),
            d ^ 4 || s === void 0
              ? ye(s) && (d > 4 ? g.unshift(s) : d ? (p ? (a = s) : (v[h] = s)) : (i = s))
              : typeof s != `object` || !s
                ? le(`Object expected`)
                : (ye((o = s.get)) && (v.get = o),
                  ye((o = s.set)) && (v.set = o),
                  ye((o = s.init)) && g.unshift(o)));
        return (d || xe(e, i), v && re(i, n, v), p ? (d ^ 4 ? a : v) : i);
      }),
      (we = (e, t, n) => ue(e, typeof t == `symbol` ? t : t + ``, n)),
      (Te = (e, t, n) => t.has(e) || le(`Cannot ` + n)),
      (Ee = (e, t) =>
        Object(t) === t ? e.has(t) : le(`Cannot use the "in" operator on this value`)),
      (De = (e, t, n) => (Te(e, t, `read from private field`), n ? n.call(e) : t.get(e))),
      (Oe = (e, t, n) =>
        t.has(e)
          ? le(`Cannot add the same private member more than once`)
          : t instanceof WeakSet
            ? t.add(e)
            : t.set(e, n)),
      (ke = (e, t, n, r) => (
        Te(e, t, `write to private field`),
        r ? r.call(e, n) : t.set(e, n),
        n
      )),
      (Ae = (e, t, n) => (Te(e, t, `access private method`), n)));
  });
function Me(e, t) {
  e.indexOf(t) === -1 && e.push(t);
}
function Ne(e, t) {
  let n = e.indexOf(t);
  n > -1 && e.splice(n, 1);
}
function Pe([...e], t, n) {
  let r = t < 0 ? e.length + t : t;
  if (r >= 0 && r < e.length) {
    let r = n < 0 ? e.length + n : n,
      [i] = e.splice(t, 1);
    e.splice(r, 0, i);
  }
  return e;
}
function Fe(e) {
  return typeof e == `object` && !!e;
}
function Ie(e) {
  let t;
  return () => (t === void 0 && (t = e()), t);
}
function Le(e, t) {
  return t ? (1e3 / t) * e : 0;
}
function Re(e, t, n, r, i) {
  let a,
    o,
    s = 0;
  do ((o = t + (n - t) / 2), (a = xs(o, r, i) - e), a > 0 ? (n = o) : (t = o));
  while (Math.abs(a) > Ss && ++s < Cs);
  return o;
}
function ze(e, t, n, r) {
  if (e === t && n === r) return N;
  let i = (t) => Re(t, 0, 1, e, n);
  return (e) => (e === 0 || e === 1 ? e : xs(i(e), t, r));
}
function Be(e, t) {
  return Is(e) ? e[bs(0, e.length, t)] : e;
}
function Ve(e, t) {
  let n = new Set(),
    r = new Set(),
    i = !1,
    a = !1,
    o = new WeakSet(),
    s = { delta: 0, timestamp: 0, isProcessing: !1 },
    c = 0;
  function l(t) {
    (o.has(t) && (u.schedule(t), e()), c++, t(s));
  }
  let u = {
    schedule: (e, t = !1, a = !1) => {
      let s = a && i ? n : r;
      return (t && o.add(e), s.has(e) || s.add(e), e);
    },
    cancel: (e) => {
      (r.delete(e), o.delete(e));
    },
    process: (e) => {
      if (((s = e), i)) {
        a = !0;
        return;
      }
      ((i = !0),
        ([n, r] = [r, n]),
        n.forEach(l),
        t && I.value && I.value.frameloop[t].push(c),
        (c = 0),
        n.clear(),
        (i = !1),
        a && ((a = !1), u.process(e)));
    },
  };
  return u;
}
function He(e, t) {
  let n = !1,
    r = !0,
    i = { delta: 0, timestamp: 0, isProcessing: !1 },
    a = () => (n = !0),
    o = Vs.reduce((e, n) => ((e[n] = Ve(a, t ? n : void 0)), e), {}),
    {
      setup: s,
      read: c,
      resolveKeyframes: l,
      preUpdate: u,
      update: d,
      preRender: f,
      render: p,
      postRender: m,
    } = o,
    h = () => {
      let a = M.useManualTiming ? i.timestamp : performance.now();
      ((n = !1),
        M.useManualTiming || (i.delta = r ? 1e3 / 60 : Math.max(Math.min(a - i.timestamp, Hs), 1)),
        (i.timestamp = a),
        (i.isProcessing = !0),
        s.process(i),
        c.process(i),
        l.process(i),
        u.process(i),
        d.process(i),
        f.process(i),
        p.process(i),
        m.process(i),
        (i.isProcessing = !1),
        n && t && ((r = !1), e(h)));
    },
    g = () => {
      ((n = !0), (r = !0), i.isProcessing || e(h));
    };
  return {
    schedule: Vs.reduce((e, t) => {
      let r = o[t];
      return ((e[t] = (e, t = !1, i = !1) => (n || g(), r.schedule(e, t, i))), e);
    }, {}),
    cancel: (e) => {
      for (let t = 0; t < Vs.length; t++) o[Vs[t]].cancel(e);
    },
    state: i,
    steps: o,
  };
}
function Ue() {
  Ws = void 0;
}
function We(e) {
  return e == null;
}
function Ge(e) {
  let t = ``,
    n = ``,
    r = ``,
    i = ``;
  return (
    e.length > 5
      ? ((t = e.substring(1, 3)),
        (n = e.substring(3, 5)),
        (r = e.substring(5, 7)),
        (i = e.substring(7, 9)))
      : ((t = e.substring(1, 2)),
        (n = e.substring(2, 3)),
        (r = e.substring(3, 4)),
        (i = e.substring(4, 5)),
        (t += t),
        (n += n),
        (r += r),
        (i += i)),
    {
      red: parseInt(t, 16),
      green: parseInt(n, 16),
      blue: parseInt(r, 16),
      alpha: i ? parseInt(i, 16) / 255 : 1,
    }
  );
}
function Ke(e) {
  return (
    isNaN(e) && typeof e == `string` && (e.match(tc)?.length || 0) + (e.match(mc)?.length || 0) > 0
  );
}
function qe(e) {
  let t = e.toString(),
    n = [],
    r = { color: [], number: [], var: [] },
    i = [],
    a = 0;
  return {
    values: n,
    split: t
      .replace(
        bc,
        (e) => (
          W.test(e)
            ? (r.color.push(a), i.push(gc), n.push(W.parse(e)))
            : e.startsWith(vc)
              ? (r.var.push(a), i.push(_c), n.push(e))
              : (r.number.push(a), i.push(hc), n.push(parseFloat(e))),
          ++a,
          yc
        )
      )
      .split(yc),
    indexes: r,
    types: i,
  };
}
function Je(e) {
  return qe(e).values;
}
function Ye(e) {
  let { split: t, types: n } = qe(e),
    r = t.length;
  return (e) => {
    let i = ``;
    for (let a = 0; a < r; a++)
      if (((i += t[a]), e[a] !== void 0)) {
        let t = n[a];
        t === hc ? (i += ec(e[a])) : t === gc ? (i += W.transform(e[a])) : (i += e[a]);
      }
    return i;
  };
}
function Xe(e) {
  let t = Je(e);
  return Ye(e)(t.map(xc));
}
function Ze(e, t, n) {
  return (
    n < 0 && (n += 1),
    n > 1 && --n,
    n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e
  );
}
function Qe({ hue: e, saturation: t, lightness: n, alpha: r }) {
  ((e /= 360), (t /= 100), (n /= 100));
  let i = 0,
    a = 0,
    o = 0;
  if (!t) i = a = o = n;
  else {
    let r = n < 0.5 ? n * (1 + t) : n + t - n * t,
      s = 2 * n - r;
    ((i = Ze(s, r, e + 1 / 3)), (a = Ze(s, r, e)), (o = Ze(s, r, e - 1 / 3)));
  }
  return {
    red: Math.round(i * 255),
    green: Math.round(a * 255),
    blue: Math.round(o * 255),
    alpha: r,
  };
}
function $e(e, t) {
  return (n) => (n > 0 ? t : e);
}
function et(e) {
  let t = wc(e);
  if (
    (ps(
      !!t,
      `'${e}' is not an animatable color. Use the equivalent color code instead.`,
      `color-not-animatable`
    ),
    !t)
  )
    return !1;
  let n = t.parse(e);
  return (t === pc && (n = Qe(n)), n);
}
function tt(e, t) {
  return Ec.has(e) ? (n) => (n <= 0 ? e : t) : (n) => (n >= 1 ? t : e);
}
function nt(e, t) {
  return (n) => K(e, t, n);
}
function rt(e) {
  return typeof e == `number`
    ? nt
    : typeof e == `string`
      ? Ys(e)
        ? $e
        : W.test(e)
          ? Tc
          : Dc
      : Array.isArray(e)
        ? it
        : typeof e == `object`
          ? W.test(e)
            ? Tc
            : at
          : $e;
}
function it(e, t) {
  let n = [...e],
    r = n.length,
    i = e.map((e, n) => rt(e)(e, t[n]));
  return (e) => {
    for (let t = 0; t < r; t++) n[t] = i[t](e);
    return n;
  };
}
function at(e, t) {
  let n = { ...e, ...t },
    r = {};
  for (let i in n) e[i] !== void 0 && t[i] !== void 0 && (r[i] = rt(e[i])(e[i], t[i]));
  return (e) => {
    for (let t in r) n[t] = r[t](e);
    return n;
  };
}
function ot(e, t) {
  let n = [],
    r = { color: 0, var: 0, number: 0 };
  for (let i = 0; i < t.values.length; i++) {
    let a = t.types[i],
      o = e.indexes[a][r[a]];
    ((n[i] = e.values[o] ?? 0), r[a]++);
  }
  return n;
}
function st(e, t, n) {
  return typeof e == `number` && typeof t == `number` && typeof n == `number`
    ? K(e, t, n)
    : rt(e)(e, t);
}
function ct(e) {
  let t = 0,
    n = e.next(t);
  for (; !n.done && t < kc; ) ((t += 50), (n = e.next(t)));
  return t >= kc ? 1 / 0 : t;
}
function lt(e, t = 100, n) {
  let r = n({ ...e, keyframes: [0, t] }),
    i = Math.min(ct(r), kc);
  return { type: `keyframes`, ease: (e) => r.next(i * e).value / t, duration: F(i) };
}
function ut(e, t, n) {
  let r = Math.max(t - Ac, 0);
  return Le(n - e(r), t - r);
}
function dt({
  duration: e = q.duration,
  bounce: t = q.bounce,
  velocity: n = q.velocity,
  mass: r = q.mass,
}) {
  let i, a;
  ps(e <= P(q.maxDuration), `Spring duration must be 10 seconds or less`, `spring-duration-limit`);
  let o = 1 - t;
  ((o = A(q.minDamping, q.maxDamping, o)),
    (e = A(q.minDuration, q.maxDuration, F(e))),
    o < 1
      ? ((i = (t) => {
          let r = t * o,
            i = r * e,
            a = r - n,
            s = pt(t, o),
            c = Math.exp(-i);
          return jc - (a / s) * c;
        }),
        (a = (t) => {
          let r = t * o * e,
            a = r * n + n,
            s = o ** 2 * t ** 2 * e,
            c = Math.exp(-r),
            l = pt(t ** 2, o);
          return ((-i(t) + jc > 0 ? -1 : 1) * ((a - s) * c)) / l;
        }))
      : ((i = (t) => {
          let r = Math.exp(-t * e),
            i = (t - n) * e + 1;
          return -jc + r * i;
        }),
        (a = (t) => Math.exp(-t * e) * ((n - t) * (e * e)))));
  let s = 5 / e,
    c = ft(i, a, s);
  if (((e = P(e)), isNaN(c))) return { stiffness: q.stiffness, damping: q.damping, duration: e };
  {
    let t = c ** 2 * r;
    return { stiffness: t, damping: o * 2 * Math.sqrt(r * t), duration: e };
  }
}
function ft(e, t, n) {
  let r = n;
  for (let n = 1; n < Mc; n++) r -= e(r) / t(r);
  return r;
}
function pt(e, t) {
  return e * Math.sqrt(1 - t * t);
}
function mt(e, t) {
  return t.some((t) => e[t] !== void 0);
}
function ht(e) {
  let t = {
    velocity: q.velocity,
    stiffness: q.stiffness,
    damping: q.damping,
    mass: q.mass,
    isResolvedFromDuration: !1,
    ...e,
  };
  if (!mt(e, Pc) && mt(e, Nc))
    if (e.visualDuration) {
      let n = e.visualDuration,
        r = (2 * Math.PI) / (n * 1.2),
        i = r * r,
        a = 2 * A(0.05, 1, 1 - (e.bounce || 0)) * Math.sqrt(i);
      t = { ...t, mass: q.mass, stiffness: i, damping: a };
    } else {
      let n = dt(e);
      ((t = { ...t, ...n, mass: q.mass }), (t.isResolvedFromDuration = !0));
    }
  return t;
}
function gt(e = q.visualDuration, t = q.bounce) {
  let n = typeof e == `object` ? e : { visualDuration: e, keyframes: [0, 1], bounce: t },
    { restSpeed: r, restDelta: i } = n,
    a = n.keyframes[0],
    o = n.keyframes[n.keyframes.length - 1],
    s = { done: !1, value: a },
    {
      stiffness: c,
      damping: l,
      mass: u,
      duration: d,
      velocity: f,
      isResolvedFromDuration: p,
    } = ht({ ...n, velocity: -F(n.velocity || 0) }),
    m = f || 0,
    h = l / (2 * Math.sqrt(c * u)),
    g = o - a,
    _ = F(Math.sqrt(c / u)),
    v = Math.abs(g) < 5;
  ((r ||= v ? q.restSpeed.granular : q.restSpeed.default),
    (i ||= v ? q.restDelta.granular : q.restDelta.default));
  let y;
  if (h < 1) {
    let e = pt(_, h);
    y = (t) =>
      o - Math.exp(-h * _ * t) * (((m + h * _ * g) / e) * Math.sin(e * t) + g * Math.cos(e * t));
  } else if (h === 1) y = (e) => o - Math.exp(-_ * e) * (g + (m + _ * g) * e);
  else {
    let e = _ * Math.sqrt(h * h - 1);
    y = (t) => {
      let n = Math.exp(-h * _ * t),
        r = Math.min(e * t, 300);
      return o - (n * ((m + h * _ * g) * Math.sinh(r) + e * g * Math.cosh(r))) / e;
    };
  }
  let b = {
    calculatedDuration: (p && d) || null,
    next: (e) => {
      let t = y(e);
      if (p) s.done = e >= d;
      else {
        let n = e === 0 ? m : 0;
        h < 1 && (n = e === 0 ? P(m) : ut(y, e, t));
        let a = Math.abs(n) <= r,
          c = Math.abs(o - t) <= i;
        s.done = a && c;
      }
      return ((s.value = s.done ? o : t), s);
    },
    toString: () => {
      let e = Math.min(ct(b), kc),
        t = Oc((t) => b.next(e * t).value, e, 30);
      return e + `ms ` + t;
    },
    toTransition: () => {},
  };
  return b;
}
function _t({
  keyframes: e,
  velocity: t = 0,
  power: n = 0.8,
  timeConstant: r = 325,
  bounceDamping: i = 10,
  bounceStiffness: a = 500,
  modifyTarget: o,
  min: s,
  max: c,
  restDelta: l = 0.5,
  restSpeed: u,
}) {
  let d = e[0],
    f = { done: !1, value: d },
    p = (e) => (s !== void 0 && e < s) || (c !== void 0 && e > c),
    m = (e) => (s === void 0 ? c : c === void 0 || Math.abs(s - e) < Math.abs(c - e) ? s : c),
    h = n * t,
    g = d + h,
    _ = o === void 0 ? g : o(g);
  _ !== g && (h = _ - d);
  let v = (e) => -h * Math.exp(-e / r),
    y = (e) => _ + v(e),
    b = (e) => {
      let t = v(e),
        n = y(e);
      ((f.done = Math.abs(t) <= l), (f.value = f.done ? _ : n));
    },
    x,
    S,
    ee = (e) => {
      p(f.value) &&
        ((x = e),
        (S = gt({
          keyframes: [f.value, m(f.value)],
          velocity: ut(y, e, f.value),
          damping: i,
          stiffness: a,
          restDelta: l,
          restSpeed: u,
        })));
    };
  return (
    ee(0),
    {
      calculatedDuration: null,
      next: (e) => {
        let t = !1;
        return (
          !S && x === void 0 && ((t = !0), b(e), ee(e)),
          x !== void 0 && e >= x ? S.next(e - x) : (!t && b(e), f)
        );
      },
    }
  );
}
function vt(e, t, n) {
  let r = [],
    i = n || M.mix || st,
    a = e.length - 1;
  for (let n = 0; n < a; n++) {
    let a = i(e[n], e[n + 1]);
    (t && (a = _s(Array.isArray(t) ? t[n] || N : t, a)), r.push(a));
  }
  return r;
}
function yt(e, t, { clamp: n = !0, ease: r, mixer: i } = {}) {
  let a = e.length;
  if (
    (j(a === t.length, `Both input and output ranges must be the same length`, `range-length`),
    a === 1)
  )
    return () => t[0];
  if (a === 2 && t[0] === t[1]) return () => t[1];
  let o = e[0] === e[1];
  e[0] > e[a - 1] && ((e = [...e].reverse()), (t = [...t].reverse()));
  let s = vt(t, r, i),
    c = s.length,
    l = (n) => {
      if (o && n < e[0]) return t[0];
      let r = 0;
      if (c > 1) for (; r < e.length - 2 && !(n < e[r + 1]); r++);
      let i = vs(e[r], e[r + 1], n);
      return s[r](i);
    };
  return n ? (t) => l(A(e[0], e[a - 1], t)) : l;
}
function bt(e, t) {
  let n = e[e.length - 1];
  for (let r = 1; r <= t; r++) {
    let i = vs(0, t, r);
    e.push(K(n, 1, i));
  }
}
function xt(e) {
  let t = [0];
  return (bt(t, e.length - 1), t);
}
function St(e, t) {
  return e.map((e) => e * t);
}
function Ct(e, t) {
  return e.map(() => t || Fs).splice(0, e.length - 1);
}
function wt({ duration: e = 300, keyframes: t, times: n, ease: r = `easeInOut` }) {
  let i = Is(r) ? r.map(Bs) : Bs(r),
    a = { done: !1, value: t[0] },
    o = yt(St(n && n.length === t.length ? n : xt(t), e), t, {
      ease: Array.isArray(i) ? i : Ct(t, i),
    });
  return { calculatedDuration: e, next: (t) => ((a.value = o(t)), (a.done = t >= e), a) };
}
function Tt(e, { repeat: t, repeatType: n = `loop` }, r, i = 1) {
  let a = e.filter(Ic),
    o = i < 0 || (t && n !== `loop` && t % 2 == 1) ? 0 : a.length - 1;
  return !o || r === void 0 ? a[o] : r;
}
function Et(e) {
  typeof e.type == `string` && (e.type = Lc[e.type]);
}
function Dt(e) {
  return new Bc(e);
}
function Ot(e) {
  for (let t = 1; t < e.length; t++) e[t] ?? (e[t] = e[t - 1]);
}
function kt(e) {
  return e.includes(`scale`) ? 1 : 0;
}
function At(e, t) {
  if (!e || e === `none`) return kt(t);
  let n = e.match(/^matrix3d\(([-\d.e\s,]+)\)$/u),
    r,
    i;
  if (n) ((r = Jc), (i = n));
  else {
    let t = e.match(/^matrix\(([-\d.e\s,]+)\)$/u);
    ((r = Uc), (i = t));
  }
  if (!i) return kt(t);
  let a = r[t],
    o = i[1].split(`,`).map(jt);
  return typeof a == `function` ? a(o) : o[a];
}
function jt(e) {
  return parseFloat(e.trim());
}
function Mt(e) {
  let t = [];
  return (
    el.forEach((n) => {
      let r = e.getValue(n);
      r !== void 0 && (t.push([n, r.get()]), r.set(n.startsWith(`scale`) ? 1 : 0));
    }),
    t
  );
}
function Nt() {
  if (rl) {
    let e = Array.from(J).filter((e) => e.needsMeasurement),
      t = new Set(e.map((e) => e.element)),
      n = new Map();
    (t.forEach((e) => {
      let t = Mt(e);
      t.length && (n.set(e, t), e.render());
    }),
      e.forEach((e) => e.measureInitialState()),
      t.forEach((e) => {
        e.render();
        let t = n.get(e);
        t &&
          t.forEach(([t, n]) => {
            e.getValue(t)?.set(n);
          });
      }),
      e.forEach((e) => e.measureEndState()),
      e.forEach((e) => {
        e.suspendedScrollY !== void 0 && o.scrollTo(0, e.suspendedScrollY);
      }));
  }
  ((rl = !1), (nl = !1), J.forEach((e) => e.complete(il)), J.clear());
}
function Pt() {
  J.forEach((e) => {
    (e.readKeyframes(), e.needsMeasurement && (rl = !0));
  });
}
function Ft() {
  ((il = !0), Pt(), Nt(), (il = !1));
}
function It(e, t, n) {
  ol(t) ? e.style.setProperty(t, n) : (e.style[t] = n);
}
function Lt(e, t) {
  let n = Ie(e);
  return () => cl[t] ?? n();
}
function Rt(e, t) {
  if (e)
    return typeof e == `function`
      ? ll()
        ? Oc(e, t)
        : `ease-out`
      : Ls(e)
        ? ul(e)
        : Array.isArray(e)
          ? e.map((e) => Rt(e, t) || dl.easeOut)
          : dl[e];
}
function zt(
  e,
  t,
  n,
  {
    delay: r = 0,
    duration: i = 300,
    repeat: a = 0,
    repeatType: o = `loop`,
    ease: s = `easeOut`,
    times: c,
  } = {},
  l = void 0
) {
  let u = { [t]: n };
  c && (u.offset = c);
  let d = Rt(s, i);
  (Array.isArray(d) && (u.easing = d), I.value && Gs.waapi++);
  let f = {
    delay: r,
    duration: i,
    easing: Array.isArray(d) ? `linear` : d,
    fill: `both`,
    iterations: a + 1,
    direction: o === `reverse` ? `alternate` : `normal`,
  };
  l && (f.pseudoElement = l);
  let p = e.animate(u, f);
  return (
    I.value &&
      p.finished.finally(() => {
        Gs.waapi--;
      }),
    p
  );
}
function Bt(e) {
  return typeof e == `function` && `applyToOptions` in e;
}
function Vt({ type: e, ...t }) {
  return Bt(e) && ll() ? e.applyToOptions(t) : ((t.duration ??= 300), (t.ease ??= `easeOut`), t);
}
function Ht(e) {
  return e in pl;
}
function Ut(e) {
  typeof e.ease == `string` && Ht(e.ease) && (e.ease = pl[e.ease]);
}
function Wt(e) {
  ((e.duration = 0), (e.type = `keyframes`));
}
function Gt(e) {
  let { motionValue: t, name: n, repeatDelay: r, repeatType: i, damping: a, type: o } = e;
  if (!(t?.owner?.current instanceof HTMLElement)) return !1;
  let { onUpdate: s, transformTemplate: c } = t.owner.getProps();
  return (
    _l() &&
    n &&
    gl.has(n) &&
    (n !== `transform` || !c) &&
    !s &&
    !r &&
    i !== `mirror` &&
    a !== 0 &&
    o !== `inertia`
  );
}
function Kt(e) {
  let t = e[0];
  if (e.length === 1) return !0;
  for (let n = 0; n < e.length; n++) if (e[n] !== t) return !0;
}
function qt(e, t, n, r) {
  let i = e[0];
  if (i === null) return !1;
  if (t === `display` || t === `visibility`) return !0;
  let a = e[e.length - 1],
    o = vl(i, t),
    s = vl(a, t);
  return (
    ps(
      o === s,
      `You are trying to animate ${t} from "${i}" to "${a}". "${o ? a : i}" is not an animatable value.`,
      `value-not-animatable`
    ),
    !o || !s ? !1 : Kt(e) || ((n === `spring` || Bt(n)) && r)
  );
}
function Jt(e, t) {
  let n = 0;
  for (let r = 0; r < e.length; r++) {
    let i = e[r][t];
    i !== null && i > n && (n = i);
  }
  return n;
}
function Yt(e) {
  let t = Cl.exec(e);
  if (!t) return [,];
  let [, n, r, i] = t;
  return [`--${n ?? r}`, i];
}
function Xt(e, t, n = 1) {
  j(
    n <= wl,
    `Max CSS variable fallback depth detected in property "${e}". This may indicate a circular fallback dependency.`,
    `max-css-var-depth`
  );
  let [r, i] = Yt(e);
  if (!r) return;
  let a = o.getComputedStyle(t).getPropertyValue(r);
  if (a) {
    let e = a.trim();
    return ms(e) ? parseFloat(e) : e;
  }
  return Ys(i) ? Xt(i, t, n + 1) : i;
}
function Zt(e, t) {
  return e?.[t] ?? e?.default ?? e;
}
function Qt(e) {
  let [t, n] = e.slice(0, -1).split(`(`);
  if (t === `drop-shadow`) return e;
  let [r] = n.match(tc) || [];
  if (!r) return e;
  let i = n.replace(r, ``),
    a = Ml.has(t) ? 1 : 0;
  return (r !== n && (a *= 100), t + `(` + a + i + `)`);
}
function $t(e, t) {
  let n = Il(e);
  return (n !== Pl && (n = G), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0);
}
function en(e) {
  return typeof e == `number` ? e === 0 : e === null ? !0 : e === `none` || e === `0` || hs(e);
}
function tn(e, t, n) {
  let r = 0,
    i;
  for (; r < e.length && !i; ) {
    let t = e[r];
    (typeof t == `string` && !Ll.has(t) && qe(t).values.length && (i = e[r]), r++);
  }
  if (i && n) for (let r of t) e[r] = $t(n, i);
}
function nn(e, t, n) {
  if (e instanceof EventTarget) return [e];
  if (typeof e == `string`) {
    let r = document;
    t && (r = t.current);
    let i = n?.[e] ?? r.querySelectorAll(e);
    return i ? Array.from(i) : [];
  }
  return Array.from(e);
}
function rn(e) {
  return Fe(e) && `offsetHeight` in e;
}
function T(e, t) {
  return new Wl(e, t);
}
function an() {
  return Y.x || Y.y;
}
function on(e) {
  return e === `x` || e === `y`
    ? Y[e]
      ? null
      : ((Y[e] = !0),
        () => {
          Y[e] = !1;
        })
    : Y.x || Y.y
      ? null
      : ((Y.x = Y.y = !0),
        () => {
          Y.x = Y.y = !1;
        });
}
function sn(e, t) {
  let n = nn(e),
    r = new AbortController();
  return [n, { passive: !0, ...t, signal: r.signal }, () => r.abort()];
}
function cn(e) {
  return !(e.pointerType === `touch` || an());
}
function ln(e, t, n = {}) {
  let [r, i, a] = sn(e, n),
    o = (e) => {
      if (!cn(e)) return;
      let { target: n } = e,
        r = t(n, e);
      if (typeof r != `function` || !n) return;
      let a = (e) => {
        cn(e) && (r(e), n.removeEventListener(`pointerleave`, a));
      };
      n.addEventListener(`pointerleave`, a, i);
    };
  return (
    r.forEach((e) => {
      e.addEventListener(`pointerenter`, o, i);
    }),
    a
  );
}
function un(e) {
  return Yl.has(e.tagName) || e.tabIndex !== -1;
}
function dn(e) {
  return (t) => {
    t.key === `Enter` && e(t);
  };
}
function fn(e, t) {
  e.dispatchEvent(new PointerEvent(`pointer` + t, { isPrimary: !0, bubbles: !0 }));
}
function pn(e) {
  return Jl(e) && !an();
}
function mn(e, t, n = {}) {
  let [r, i, a] = sn(e, n),
    s = (e) => {
      let r = e.currentTarget;
      if (!pn(e)) return;
      Xl.add(r);
      let a = t(r, e),
        s = (e, t) => {
          (o.removeEventListener(`pointerup`, c),
            o.removeEventListener(`pointercancel`, l),
            Xl.has(r) && Xl.delete(r),
            pn(e) && typeof a == `function` && a(e, { success: t }));
        },
        c = (e) => {
          s(e, r === o || r === document || n.useGlobalTarget || ql(r, e.target));
        },
        l = (e) => {
          s(e, !1);
        };
      (o.addEventListener(`pointerup`, c, i), o.addEventListener(`pointercancel`, l, i));
    };
  return (
    r.forEach((e) => {
      ((n.useGlobalTarget ? o : e).addEventListener(`pointerdown`, s, i),
        rn(e) &&
          (e.addEventListener(`focus`, (e) => Zl(e, i)),
          !un(e) && !e.hasAttribute(`tabindex`) && (e.tabIndex = 0)));
    }),
    a
  );
}
function hn(e) {
  return Fe(e) && `ownerSVGElement` in e;
}
function gn({ target: e, borderBoxSize: t }) {
  Ql.get(e)?.forEach((n) => {
    n(e, {
      get width() {
        return tu(e, t);
      },
      get height() {
        return nu(e, t);
      },
    });
  });
}
function _n(e) {
  e.forEach(gn);
}
function vn() {
  typeof ResizeObserver > `u` || ($l = new ResizeObserver(_n));
}
function yn(e, t) {
  $l || vn();
  let n = nn(e);
  return (
    n.forEach((e) => {
      let n = Ql.get(e);
      (n || ((n = new Set()), Ql.set(e, n)), n.add(t), $l?.observe(e));
    }),
    () => {
      n.forEach((e) => {
        let n = Ql.get(e);
        (n?.delete(t), n?.size || $l?.unobserve(e));
      });
    }
  );
}
function bn() {
  ((iu = () => {
    let e = {
      get width() {
        return o.innerWidth;
      },
      get height() {
        return o.innerHeight;
      },
    };
    ru.forEach((t) => t(e));
  }),
    o.addEventListener(`resize`, iu));
}
function xn(e) {
  return (
    ru.add(e),
    iu || bn(),
    () => {
      (ru.delete(e),
        !ru.size &&
          typeof iu == `function` &&
          (o.removeEventListener(`resize`, iu), (iu = void 0)));
    }
  );
}
function Sn(e, t) {
  return typeof e == `function` ? xn(e) : yn(e, t);
}
function Cn(e, t) {
  let n,
    r = () => {
      let { currentTime: r } = t,
        i = (r === null ? 0 : r.value) / 100;
      (n !== i && e(i), (n = i));
    };
  return (L.preUpdate(r, !0), () => R(r));
}
function wn(e) {
  return hn(e) && e.tagName === `svg`;
}
function Tn(e, t) {
  if (e === `first`) return 0;
  {
    let n = t - 1;
    return e === `last` ? n : n / 2;
  }
}
function En(e = 0.1, { startDelay: t = 0, from: n = 0, ease: r } = {}) {
  return (i, a) => {
    let o = typeof n == `number` ? n : Tn(n, a),
      s = e * Math.abs(o - i);
    if (r) {
      let t = a * e;
      s = Bs(r)(s / t) * t;
    }
    return t + s;
  };
}
function Dn(...e) {
  let t = !Array.isArray(e[0]),
    n = t ? 0 : -1,
    r = e[0 + n],
    i = e[1 + n],
    a = e[2 + n],
    o = e[3 + n],
    s = yt(i, a, o);
  return t ? s(r) : s;
}
function On(e, t, n) {
  let r = () => t.set(n()),
    i = () => L.preRender(r, !1, !0),
    a = e.map((e) => e.on(`change`, i));
  t.on(`destroy`, () => {
    (a.forEach((e) => e()), R(r));
  });
}
function kn(e) {
  let t = [];
  Ul.current = t;
  let n = e();
  Ul.current = void 0;
  let r = T(n);
  return (On(t, r, e), r);
}
function An(e, t, n) {
  let r = e.get(),
    i = null,
    a = r,
    o,
    s = typeof r == `string` ? r.replace(/[\d.-]/g, ``) : void 0,
    c = () => {
      i &&= (i.stop(), null);
    },
    l = () => {
      (c(),
        (i = new Bc({
          keyframes: [Mn(e.get()), Mn(a)],
          velocity: e.getVelocity(),
          type: `spring`,
          restDelta: 0.001,
          restSpeed: 0.01,
          ...n,
          onUpdate: o,
        })));
    };
  if (
    (e.attach((e, t) => {
      ((a = e), (o = (e) => t(jn(e, s))), L.postRender(l));
    }, c),
    X(t))
  ) {
    let n = t.on(`change`, (t) => e.set(jn(t, s))),
      r = e.on(`destroy`, n);
    return () => {
      (n(), r());
    };
  }
  return c;
}
function jn(e, t) {
  return t ? e + t : e;
}
function Mn(e) {
  return typeof e == `number` ? e : parseFloat(e);
}
function Nn(e, t) {
  if (typeof e == `function`) return e(t);
  e != null && (e.current = t);
}
function Pn(...e) {
  return (t) => {
    let n = !1,
      r = e.map((e) => {
        let r = Nn(e, t);
        return (!n && typeof r == `function` && (n = !0), r);
      });
    if (n)
      return () => {
        for (let t = 0; t < r.length; t++) {
          let n = r[t];
          typeof n == `function` ? n() : Nn(e[t], null);
        }
      };
  };
}
function Fn(...e) {
  return a(Pn(...e), e);
}
function In({ children: e, isPresent: t, anchorX: n, root: r }) {
  let i = g(),
    a = b(null),
    o = b({ width: 0, height: 0, top: 0, left: 0, right: 0 }),
    { nonce: s } = u(Z),
    c = Fn(a, e?.ref);
  return (
    p(() => {
      let { width: e, height: c, top: l, left: u, right: d } = o.current;
      if (t || !a.current || !e || !c) return;
      let f = n === `left` ? `left: ${u}` : `right: ${d}`;
      a.current.dataset.motionPopId = i;
      let p = document.createElement(`style`);
      s && (p.nonce = s);
      let m = r ?? document.head;
      return (
        m.appendChild(p),
        p.sheet &&
          p.sheet.insertRule(`
          [data-motion-pop-id="${i}"] {
            position: absolute !important;
            width: ${e}px !important;
            height: ${c}px !important;
            ${f}px !important;
            top: ${l}px !important;
          }
        `),
        () => {
          m.contains(p) && m.removeChild(p);
        }
      );
    }, [t]),
    _(su, { isPresent: t, childRef: a, sizeRef: o, children: l(e, { ref: c }) })
  );
}
function E(e) {
  let t = b(null);
  return (t.current === null && (t.current = e()), t.current);
}
function Ln() {
  return new Map();
}
function Rn(e = !0) {
  let t = u(fs);
  if (t === null) return [!0, null];
  let { isPresent: n, onExitComplete: r, register: i } = t,
    o = g();
  s(() => {
    if (e) return i(o);
  }, [e]);
  let c = a(() => e && r && r(o), [o, r, e]);
  return !n && r ? [!1, c] : [!0];
}
function zn(e) {
  let t = [];
  return (
    r.forEach(e, (e) => {
      y(e) && t.push(e);
    }),
    t
  );
}
function Bn() {
  let e = b(!1);
  return (
    ds(
      () => (
        (e.current = !0),
        () => {
          e.current = !1;
        }
      ),
      []
    ),
    e
  );
}
function Vn() {
  let e = Bn(),
    [t, n] = f(0),
    r = a(() => {
      e.current && n(t + 1);
    }, [t]);
  return [a(() => L.postRender(r), [r]), t];
}
function Hn() {
  let e = new Set(),
    t = new WeakMap(),
    n = () => e.forEach(fu);
  return {
    add: (r) => {
      (e.add(r), t.set(r, r.addEventListener(`willUpdate`, n)));
    },
    remove: (r) => {
      e.delete(r);
      let i = t.get(r);
      (i && (i(), t.delete(r)), n());
    },
    dirty: n,
  };
}
function Un(e) {
  for (let t in e) vu[t] = { ...vu[t], ...e[t] };
}
function Wn(e) {
  return (
    e.startsWith(`while`) ||
    (e.startsWith(`drag`) && e !== `draggable`) ||
    e.startsWith(`layout`) ||
    e.startsWith(`onTap`) ||
    e.startsWith(`onPan`) ||
    e.startsWith(`onLayout`) ||
    yu.has(e)
  );
}
function Gn(e) {
  typeof e == `function` && (bu = (t) => (t.startsWith(`on`) ? !Wn(t) : e(t)));
}
function Kn(e, t, n) {
  let r = {};
  for (let i in e)
    (i === `values` && typeof e.values == `object`) ||
      ((bu(i) ||
        (n === !0 && Wn(i)) ||
        (!t && !Wn(i)) ||
        (e.draggable && i.startsWith(`onDrag`))) &&
        (r[i] = e[i]));
  return r;
}
function qn({ children: e, isValidProp: t, ...n }) {
  (t && Gn(t), (n = { ...u(Z), ...n }), (n.isStatic = E(() => n.isStatic)));
  let r = d(() => n, [JSON.stringify(n.transition), n.transformPagePoint, n.reducedMotion]);
  return _(Z.Provider, { value: r, children: e });
}
function Jn(e, t) {
  return t.max === t.min ? 0 : (e / (t.max - t.min)) * 100;
}
function Yn(e) {
  for (let t in e) ((wu[t] = e[t]), qs(t) && (wu[t].isCSSVariable = !0));
}
function Xn(e, t, n) {
  let r = ``,
    i = !0;
  for (let a = 0; a < Eu; a++) {
    let o = Xc[a],
      s = e[o];
    if (s === void 0) continue;
    let c = !0;
    if (
      ((c = typeof s == `number` ? s === (o.startsWith(`scale`) ? 1 : 0) : parseFloat(s) === 0),
      !c || n)
    ) {
      let e = Bl(s, jl[o]);
      if (!c) {
        i = !1;
        let t = Tu[o] || o;
        r += `${t}(${e}) `;
      }
      n && (t[o] = e);
    }
  }
  return ((r = r.trim()), n ? (r = n(t, i ? `` : r)) : i && (r = `none`), r);
}
function Zn(e) {
  return X(e) ? e.get() : e;
}
function Qn(e) {
  return typeof e == `object` && !!e && typeof e.start == `function`;
}
function $n(e) {
  return typeof e == `string` || Array.isArray(e);
}
function er(e) {
  return Qn(e.animate) || Ou.some((t) => $n(e[t]));
}
function tr(e) {
  return !!(er(e) || e.variants);
}
function nr(e) {
  let t = [{}, {}];
  return (
    e?.values.forEach((e, n) => {
      ((t[0][n] = e.get()), (t[1][n] = e.getVelocity()));
    }),
    t
  );
}
function rr(e, t, n, r) {
  if (typeof t == `function`) {
    let [i, a] = nr(r);
    t = t(n === void 0 ? e.custom : n, i, a);
  }
  if ((typeof t == `string` && (t = e.variants && e.variants[t]), typeof t == `function`)) {
    let [i, a] = nr(r);
    t = t(n === void 0 ? e.custom : n, i, a);
  }
  return t;
}
function ir({ scrapeMotionValuesFromProps: e, createRenderState: t }, n, r, i) {
  return { latestValues: ar(n, r, i, e), renderState: t() };
}
function ar(e, t, n, r) {
  let i = {},
    a = r(e, {});
  for (let e in a) i[e] = Zn(a[e]);
  let { initial: o, animate: s } = e,
    c = er(e),
    l = tr(e);
  t &&
    l &&
    !c &&
    e.inherit !== !1 &&
    (o === void 0 && (o = t.initial), s === void 0 && (s = t.animate));
  let u = n ? n.initial === !1 : !1;
  u ||= o === !1;
  let d = u ? s : o;
  if (d && typeof d != `boolean` && !Qn(d)) {
    let t = Array.isArray(d) ? d : [d];
    for (let n = 0; n < t.length; n++) {
      let r = rr(e, t[n]);
      if (r) {
        let { transitionEnd: e, transition: t, ...n } = r;
        for (let e in n) {
          let t = n[e];
          if (Array.isArray(t)) {
            let e = u ? t.length - 1 : 0;
            t = t[e];
          }
          t !== null && (i[e] = t);
        }
        for (let t in e) i[t] = e[t];
      }
    }
  }
  return i;
}
function or(e, t) {
  if (er(e)) {
    let { initial: t, animate: n } = e;
    return { initial: t === !1 || $n(t) ? t : void 0, animate: $n(n) ? n : void 0 };
  }
  return e.inherit === !1 ? {} : t;
}
function sr(e) {
  let { initial: t, animate: n } = or(e, u(xu));
  return d(() => ({ initial: t, animate: n }), [cr(t), cr(n)]);
}
function cr(e) {
  return Array.isArray(e) ? e.join(` `) : e;
}
function lr(e, { layout: t, layoutId: n }) {
  return (
    Zc.has(e) || e.startsWith(`origin`) || ((t || n !== void 0) && (!!wu[e] || e === `opacity`))
  );
}
function ur(e, t, n) {
  let { style: r, vars: i, transformOrigin: a } = e,
    o = !1,
    s = !1;
  for (let e in t) {
    let n = t[e];
    if (Zc.has(e)) {
      o = !0;
      continue;
    } else if (qs(e)) {
      i[e] = n;
      continue;
    } else {
      let t = Bl(n, jl[e]);
      e.startsWith(`origin`) ? ((s = !0), (a[e] = t)) : (r[e] = t);
    }
  }
  if (
    (t.transform || (o || n ? (r.transform = Xn(t, e.transform, n)) : (r.transform &&= `none`)), s)
  ) {
    let { originX: e = `50%`, originY: t = `50%`, originZ: n = 0 } = a;
    r.transformOrigin = `${e} ${t} ${n}`;
  }
}
function dr(e, t, n) {
  for (let r in t) !X(t[r]) && !lr(r, n) && (e[r] = t[r]);
}
function fr({ transformTemplate: e }, t) {
  return d(() => {
    let n = Pu();
    return (ur(n, t, e), Object.assign({}, n.vars, n.style));
  }, [t]);
}
function pr(e, t) {
  let n = e.style || {},
    r = {};
  return (dr(r, n, e), Object.assign(r, fr(e, t)), r);
}
function mr(e, t) {
  let n = {},
    r = pr(e, t);
  return (
    e.drag &&
      e.dragListener !== !1 &&
      ((n.draggable = !1),
      (r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = `none`),
      (r.touchAction = e.drag === !0 ? `none` : `pan-${e.drag === `x` ? `y` : `x`}`)),
    e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0),
    (n.style = r),
    n
  );
}
function hr(e, t, n = 1, r = 0, i = !0) {
  e.pathLength = 1;
  let a = i ? Fu : Iu;
  e[a.offset] = U.transform(-r);
  let o = U.transform(t),
    s = U.transform(n);
  e[a.array] = `${o} ${s}`;
}
function gr(
  e,
  { attrX: t, attrY: n, attrScale: r, pathLength: i, pathSpacing: a = 1, pathOffset: o = 0, ...s },
  c,
  l,
  u
) {
  if ((ur(e, s, l), c)) {
    e.style.viewBox && (e.attrs.viewBox = e.style.viewBox);
    return;
  }
  ((e.attrs = e.style), (e.style = {}));
  let { attrs: d, style: f } = e;
  (d.transform && ((f.transform = d.transform), delete d.transform),
    (f.transform || d.transformOrigin) &&
      ((f.transformOrigin = d.transformOrigin ?? `50% 50%`), delete d.transformOrigin),
    f.transform && ((f.transformBox = u?.transformBox ?? `fill-box`), delete d.transformBox),
    t !== void 0 && (d.x = t),
    n !== void 0 && (d.y = n),
    r !== void 0 && (d.scale = r),
    i !== void 0 && hr(d, i, a, o, !1));
}
function _r(e, t, n, r) {
  let i = d(() => {
    let n = Lu();
    return (gr(n, t, Ru(r), e.transformTemplate, e.style), { ...n.attrs, style: { ...n.style } });
  }, [t]);
  if (e.style) {
    let t = {};
    (dr(t, e.style, e), (i.style = { ...t, ...i.style }));
  }
  return i;
}
function vr(e) {
  return typeof e != `string` || e.includes(`-`) ? !1 : !!(zu.indexOf(e) > -1 || /[A-Z]/u.test(e));
}
function yr(e, t, n, { latestValues: r }, i, a = !1) {
  let o = (vr(e) ? _r : mr)(t, r, i, e),
    s = Kn(t, typeof e == `string`, a),
    l = e === c ? {} : { ...s, ...o, ref: n },
    { children: u } = t,
    f = d(() => (X(u) ? u.get() : u), [u]);
  return C(e, { ...l, children: f });
}
function br(e, t, n) {
  let { style: r } = e,
    i = {};
  for (let a in r)
    (X(r[a]) || (t.style && X(t.style[a])) || lr(a, e) || n?.getValue(a)?.liveStyle !== void 0) &&
      (i[a] = r[a]);
  return i;
}
function xr(e, t, n) {
  let r = br(e, t, n);
  for (let n in e)
    if (X(e[n]) || X(t[n])) {
      let t = Xc.indexOf(n) === -1 ? n : `attr` + n.charAt(0).toUpperCase() + n.substring(1);
      r[t] = e[n];
    }
  return r;
}
function Sr(e) {
  return e && typeof e == `object` && Object.prototype.hasOwnProperty.call(e, `current`);
}
function Cr(e, t, n) {
  return a(
    (r) => {
      (r && e.onMount && e.onMount(r),
        t && (r ? t.mount(r) : t.unmount()),
        n && (typeof n == `function` ? n(r) : Sr(n) && (n.current = r)));
    },
    [t]
  );
}
function wr(e, t, n, r, i) {
  let { visualElement: a } = u(xu),
    c = u(gu),
    l = u(fs),
    d = u(Z).reducedMotion,
    f = b(null);
  ((r ||= c.renderer),
    !f.current &&
      r &&
      (f.current = r(e, {
        visualState: t,
        parent: a,
        props: n,
        presenceContext: l,
        blockInitialAnimation: l ? l.initial === !1 : !1,
        reducedMotionConfig: d,
      })));
  let m = f.current,
    h = u(Nu);
  m && !m.projection && i && (m.type === `html` || m.type === `svg`) && Tr(f.current, n, i, h);
  let g = b(!1);
  p(() => {
    m && g.current && m.update(n, l);
  });
  let _ = n[Mu],
    v = b(!!_ && !o.MotionHandoffIsComplete?.(_) && o.MotionHasOptimisedAnimation?.(_));
  return (
    ds(() => {
      m &&
        ((g.current = !0),
        (o.MotionIsMounted = !0),
        m.updateFeatures(),
        m.scheduleRenderMicrotask(),
        v.current && m.animationState && m.animationState.animateChanges());
    }),
    s(() => {
      m &&
        (!v.current && m.animationState && m.animationState.animateChanges(),
        (v.current &&=
          (queueMicrotask(() => {
            o.MotionHandoffMarkAsComplete?.(_);
          }),
          !1)),
        (m.enteringChildren = void 0));
    }),
    m
  );
}
function Tr(e, t, n, r) {
  let {
    layoutId: i,
    layout: a,
    drag: o,
    dragConstraints: s,
    layoutScroll: c,
    layoutRoot: l,
    layoutCrossfade: u,
  } = t;
  ((e.projection = new n(e.latestValues, t[`data-framer-portal-id`] ? void 0 : Er(e.parent))),
    e.projection.setOptions({
      layoutId: i,
      layout: a,
      alwaysMeasureLayout: !!o || (s && Sr(s)),
      visualElement: e,
      animationType: typeof a == `string` ? a : `both`,
      initialPromotionConfig: r,
      crossfade: u,
      layoutScroll: c,
      layoutRoot: l,
    }));
}
function Er(e) {
  if (e) return e.options.allowProjection === !1 ? Er(e.parent) : e.projection;
}
function Dr(e, { forwardMotionProps: t = !1 } = {}, n, r) {
  n && Un(n);
  let i = vr(e) ? Vu : Bu;
  function a(a, o) {
    let s,
      c = { ...u(Z), ...a, layoutId: Or(a) },
      { isStatic: l } = c,
      d = sr(a),
      f = i(a, l);
    if (!l && us) {
      kr(c, n);
      let t = Ar(c);
      ((s = t.MeasureLayout), (d.visualElement = wr(e, f, c, r, t.ProjectionNode)));
    }
    return x(xu.Provider, {
      value: d,
      children: [
        s && d.visualElement ? _(s, { visualElement: d.visualElement, ...c }) : null,
        yr(e, a, Cr(f, d.visualElement, o), f, l, t),
      ],
    });
  }
  a.displayName = `motion.${typeof e == `string` ? e : `create(${e.displayName ?? e.name ?? ``})`}`;
  let o = h(a);
  return ((o[Hu] = e), o);
}
function Or({ layoutId: e }) {
  let t = u(ls).id;
  return t && e !== void 0 ? t + `-` + e : e;
}
function kr(e, t) {
  u(gu).strict;
}
function Ar(e) {
  let { drag: t, layout: n } = vu;
  if (!t && !n) return {};
  let r = { ...t, ...n };
  return {
    MeasureLayout: t?.isEnabled(e) || n?.isEnabled(e) ? r.MeasureLayout : void 0,
    ProjectionNode: r.ProjectionNode,
  };
}
function jr(e, t) {
  if (typeof Proxy > `u`) return Dr;
  let n = new Map(),
    r = (n, r) => Dr(n, r, e, t);
  return new Proxy((e, t) => r(e, t), {
    get: (i, a) => (a === `create` ? r : (n.has(a) || n.set(a, Dr(a, void 0, e, t)), n.get(a))),
  });
}
function Mr() {
  if (((Ju.current = !0), us))
    if (o.matchMedia) {
      let e = o.matchMedia(`(prefers-reduced-motion)`),
        t = () => (qu.current = e.matches);
      (e.addEventListener(`change`, t), t());
    } else qu.current = !1;
}
function Nr(e, t, n) {
  for (let r in t) {
    let i = t[r],
      a = n[r];
    if (X(i)) e.addValue(r, i);
    else if (X(a)) e.addValue(r, T(i, { owner: e }));
    else if (a !== i)
      if (e.hasValue(r)) {
        let t = e.getValue(r);
        t.liveStyle === !0 ? t.jump(i) : t.hasAnimated || t.set(i);
      } else {
        let t = e.getStaticValue(r);
        e.addValue(r, T(t === void 0 ? i : t, { owner: e }));
      }
  }
  for (let r in n) t[r] === void 0 && e.removeValue(r);
  return t;
}
function Pr(e, t, n) {
  let r = e.getProps();
  return rr(r, t, n === void 0 ? r.custom : n, e);
}
function Fr(e, t, n) {
  e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, T(n));
}
function Ir(e) {
  return Zu(e) ? e[e.length - 1] || 0 : e;
}
function Lr(e, t) {
  let { transitionEnd: n = {}, transition: r = {}, ...i } = Pr(e, t) || {};
  for (let t in ((i = { ...i, ...n }), i)) Fr(e, t, Ir(i[t]));
}
function Rr(e) {
  return !!(X(e) && e.add);
}
function zr(e, t) {
  let n = e.getValue(`willChange`);
  if (Rr(n)) return n.add(t);
  if (!n && M.WillChange) {
    let n = new M.WillChange(`auto`);
    (e.addValue(`willChange`, n), n.add(t));
  }
}
function Br(e) {
  return e.props[Mu];
}
function Vr(e, { repeat: t, repeatType: n = `loop` }, r) {
  let i = e.filter(Qu),
    a = t && n !== `loop` && t % 2 == 1 ? 0 : i.length - 1;
  return !a || r === void 0 ? i[a] : r;
}
function Hr({
  when: e,
  delay: t,
  delayChildren: n,
  staggerChildren: r,
  staggerDirection: i,
  repeat: a,
  repeatType: o,
  repeatDelay: s,
  from: c,
  elapsed: l,
  ...u
}) {
  return !!Object.keys(u).length;
}
function Ur({ protectedKeys: e, needsAnimating: t }, n) {
  let r = e.hasOwnProperty(n) && t[n] !== !0;
  return ((t[n] = !1), r);
}
function Wr(e, t, { delay: n = 0, transitionOverride: r, type: i } = {}) {
  let { transition: a = e.getDefaultTransition(), transitionEnd: s, ...c } = t;
  r && (a = r);
  let l = [],
    u = i && e.animationState && e.animationState.getState()[i];
  for (let t in c) {
    let r = e.getValue(t, e.latestValues[t] ?? null),
      i = c[t];
    if (i === void 0 || (u && Ur(u, t))) continue;
    let s = { delay: n, ...Zt(a || {}, t) },
      d = r.get();
    if (d !== void 0 && !r.isAnimating && !Array.isArray(i) && i === d && !s.velocity) continue;
    let f = !1;
    if (o.MotionHandoffAnimation) {
      let n = Br(e);
      if (n) {
        let e = o.MotionHandoffAnimation(n, t, L);
        e !== null && ((s.startTime = e), (f = !0));
      }
    }
    (zr(e, t), r.start(id(t, r, i, e.shouldReduceMotion && Tl.has(t) ? { type: !1 } : s, e, f)));
    let p = r.animation;
    p && l.push(p);
  }
  return (
    s &&
      Promise.all(l).then(() => {
        L.update(() => {
          s && Lr(e, s);
        });
      }),
    l
  );
}
function Gr(e, t, n, r = 0, i = 1) {
  let a = Array.from(e)
      .sort((e, t) => e.sortNodePosition(t))
      .indexOf(t),
    o = e.size,
    s = (o - 1) * r;
  return typeof n == `function` ? n(a, o) : i === 1 ? a * r : s - a * r;
}
function Kr(e, t, n = {}) {
  let r = Pr(e, t, n.type === `exit` ? e.presenceContext?.custom : void 0),
    { transition: i = e.getDefaultTransition() || {} } = r || {};
  n.transitionOverride && (i = n.transitionOverride);
  let a = r ? () => Promise.all(Wr(e, r, n)) : () => Promise.resolve(),
    o =
      e.variantChildren && e.variantChildren.size
        ? (r = 0) => {
            let { delayChildren: a = 0, staggerChildren: o, staggerDirection: s } = i;
            return qr(e, t, r, a, o, s, n);
          }
        : () => Promise.resolve(),
    { when: s } = i;
  if (s) {
    let [e, t] = s === `beforeChildren` ? [a, o] : [o, a];
    return e().then(() => t());
  } else return Promise.all([a(), o(n.delay)]);
}
function qr(e, t, n = 0, r = 0, i = 0, a = 1, o) {
  let s = [];
  for (let c of e.variantChildren)
    (c.notify(`AnimationStart`, t),
      s.push(
        Kr(c, t, {
          ...o,
          delay: n + (typeof r == `function` ? 0 : r) + Gr(e.variantChildren, c, r, i, a),
        }).then(() => c.notify(`AnimationComplete`, t))
      ));
  return Promise.all(s);
}
function Jr(e, t, n = {}) {
  e.notify(`AnimationStart`, t);
  let r;
  if (Array.isArray(t)) {
    let i = t.map((t) => Kr(e, t, n));
    r = Promise.all(i);
  } else if (typeof t == `string`) r = Kr(e, t, n);
  else {
    let i = typeof t == `function` ? Pr(e, t, n.custom) : t;
    r = Promise.all(Wr(e, i, n));
  }
  return r.then(() => {
    e.notify(`AnimationComplete`, t);
  });
}
function Yr(e, t) {
  if (!Array.isArray(t)) return !1;
  let n = t.length;
  if (n !== e.length) return !1;
  for (let r = 0; r < n; r++) if (t[r] !== e[r]) return !1;
  return !0;
}
function Xr(e) {
  if (!e) return;
  if (!e.isControllingVariants) {
    let t = (e.parent && Xr(e.parent)) || {};
    return (e.props.initial !== void 0 && (t.initial = e.props.initial), t);
  }
  let t = {};
  for (let n = 0; n < ad; n++) {
    let r = Ou[n],
      i = e.props[r];
    ($n(i) || i === !1) && (t[r] = i);
  }
  return t;
}
function Zr(e) {
  return (t) => Promise.all(t.map(({ animation: t, options: n }) => Jr(e, t, n)));
}
function Qr(e) {
  let t = Zr(e),
    n = ti(),
    r = !0,
    i = (t) => (n, r) => {
      let i = Pr(e, r, t === `exit` ? e.presenceContext?.custom : void 0);
      if (i) {
        let { transition: e, transitionEnd: t, ...r } = i;
        n = { ...n, ...r, ...t };
      }
      return n;
    };
  function a(n) {
    t = n(e);
  }
  function o(a) {
    let { props: o } = e,
      s = Xr(e.parent) || {},
      c = [],
      l = new Set(),
      u = {},
      d = 1 / 0;
    for (let t = 0; t < sd; t++) {
      let f = od[t],
        p = n[f],
        m = o[f] === void 0 ? s[f] : o[f],
        h = $n(m),
        g = f === a ? p.isActive : null;
      g === !1 && (d = t);
      let _ = m === s[f] && m !== o[f] && h;
      if (
        (_ && r && e.manuallyAnimateOnMount && (_ = !1),
        (p.protectedKeys = { ...u }),
        (!p.isActive && g === null) || (!m && !p.prevProp) || Qn(m) || typeof m == `boolean`)
      )
        continue;
      let v = $r(p.prevProp, m),
        y = v || (f === a && p.isActive && !_ && h) || (t > d && h),
        b = !1,
        x = Array.isArray(m) ? m : [m],
        S = x.reduce(i(f), {});
      g === !1 && (S = {});
      let { prevResolvedValues: ee = {} } = p,
        C = { ...ee, ...S },
        te = (t) => {
          ((y = !0), l.has(t) && ((b = !0), l.delete(t)), (p.needsAnimating[t] = !0));
          let n = e.getValue(t);
          n && (n.liveStyle = !1);
        };
      for (let e in C) {
        let t = S[e],
          n = ee[e];
        if (u.hasOwnProperty(e)) continue;
        let r = !1;
        ((r = Zu(t) && Zu(n) ? !Yr(t, n) : t !== n),
          r
            ? t == null
              ? l.add(e)
              : te(e)
            : t !== void 0 && l.has(e)
              ? te(e)
              : (p.protectedKeys[e] = !0));
      }
      ((p.prevProp = m),
        (p.prevResolvedValues = S),
        p.isActive && (u = { ...u, ...S }),
        r && e.blockInitialAnimation && (y = !1));
      let w = _ && v;
      y &&
        (!w || b) &&
        c.push(
          ...x.map((t) => {
            let n = { type: f };
            if (typeof t == `string` && r && !w && e.manuallyAnimateOnMount && e.parent) {
              let { parent: r } = e,
                i = Pr(r, t);
              if (r.enteringChildren && i) {
                let { delayChildren: t } = i.transition || {};
                n.delay = Gr(r.enteringChildren, e, t);
              }
            }
            return { animation: t, options: n };
          })
        );
    }
    if (l.size) {
      let t = {};
      if (typeof o.initial != `boolean`) {
        let n = Pr(e, Array.isArray(o.initial) ? o.initial[0] : o.initial);
        n && n.transition && (t.transition = n.transition);
      }
      (l.forEach((n) => {
        let r = e.getBaseTarget(n),
          i = e.getValue(n);
        (i && (i.liveStyle = !0), (t[n] = r ?? null));
      }),
        c.push({ animation: t }));
    }
    let f = !!c.length;
    return (
      r && (o.initial === !1 || o.initial === o.animate) && !e.manuallyAnimateOnMount && (f = !1),
      (r = !1),
      f ? t(c) : Promise.resolve()
    );
  }
  function s(t, r) {
    if (n[t].isActive === r) return Promise.resolve();
    (e.variantChildren?.forEach((e) => e.animationState?.setActive(t, r)), (n[t].isActive = r));
    let i = o(t);
    for (let e in n) n[e].protectedKeys = {};
    return i;
  }
  return {
    animateChanges: o,
    setActive: s,
    setAnimateFunction: a,
    getState: () => n,
    reset: () => {
      n = ti();
    },
  };
}
function $r(e, t) {
  return typeof t == `string` ? t !== e : Array.isArray(t) ? !Yr(t, e) : !1;
}
function ei(e = !1) {
  return { isActive: e, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} };
}
function ti() {
  return {
    animate: ei(!0),
    whileInView: ei(),
    whileHover: ei(),
    whileTap: ei(),
    whileDrag: ei(),
    whileFocus: ei(),
    exit: ei(),
  };
}
function ni(e) {
  return { point: { x: e.pageX, y: e.pageY } };
}
function ri(e, t, n, r = { passive: !0 }) {
  return (e.addEventListener(t, n, r), () => e.removeEventListener(t, n));
}
function ii(e, t, n, r) {
  return ri(e, t, fd(n), r);
}
function D(e) {
  return e.max - e.min;
}
function ai(e, t, n) {
  return Math.abs(e - t) <= n;
}
function oi(e, t, n, r = 0.5) {
  ((e.origin = r),
    (e.originPoint = K(t.min, t.max, e.origin)),
    (e.scale = D(n) / D(t)),
    (e.translate = K(n.min, n.max, e.origin) - e.originPoint),
    ((e.scale >= md && e.scale <= hd) || isNaN(e.scale)) && (e.scale = 1),
    ((e.translate >= _d && e.translate <= vd) || isNaN(e.translate)) && (e.translate = 0));
}
function si(e, t, n, r) {
  (oi(e.x, t.x, n.x, r ? r.originX : void 0), oi(e.y, t.y, n.y, r ? r.originY : void 0));
}
function ci(e, t, n) {
  ((e.min = n.min + t.min), (e.max = e.min + D(t)));
}
function li(e, t, n) {
  (ci(e.x, t.x, n.x), ci(e.y, t.y, n.y));
}
function ui(e, t, n) {
  ((e.min = t.min - n.min), (e.max = e.min + D(t)));
}
function di(e, t, n) {
  (ui(e.x, t.x, n.x), ui(e.y, t.y, n.y));
}
function fi(e, t) {
  let n = yd(e.x, t.x),
    r = yd(e.y, t.y);
  return Math.sqrt(n ** 2 + r ** 2);
}
function pi(e, t) {
  let n = B.now(),
    r = ({ timestamp: i }) => {
      let a = i - n;
      a >= t && (R(r), e(a - t));
    };
  return (L.setup(r, !0), () => R(r));
}
function mi({ top: e, left: t, right: n, bottom: r }) {
  return { x: { min: t, max: n }, y: { min: e, max: r } };
}
function hi({ x: e, y: t }) {
  return { top: t.min, right: e.max, bottom: t.max, left: e.min };
}
function gi(e, t) {
  if (!t) return e;
  let n = t({ x: e.left, y: e.top }),
    r = t({ x: e.right, y: e.bottom });
  return { top: n.y, left: n.x, bottom: r.y, right: r.x };
}
function _i(e) {
  return e === void 0 || e === 1;
}
function vi({ scale: e, scaleX: t, scaleY: n }) {
  return !_i(e) || !_i(t) || !_i(n);
}
function yi(e) {
  return vi(e) || bi(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY;
}
function bi(e) {
  return xi(e.x) || xi(e.y);
}
function xi(e) {
  return e && e !== `0%`;
}
function Si(e, t, n) {
  return n + t * (e - n);
}
function Ci(e, t, n, r, i) {
  return (i !== void 0 && (e = Si(e, i, r)), Si(e, n, r) + t);
}
function wi(e, t = 0, n = 1, r, i) {
  ((e.min = Ci(e.min, t, n, r, i)), (e.max = Ci(e.max, t, n, r, i)));
}
function Ti(e, { x: t, y: n }) {
  (wi(e.x, t.translate, t.scale, t.originPoint), wi(e.y, n.translate, n.scale, n.originPoint));
}
function Ei(e, t, n, r = !1) {
  let i = n.length;
  if (!i) return;
  t.x = t.y = 1;
  let a, o;
  for (let s = 0; s < i; s++) {
    ((a = n[s]), (o = a.projectionDelta));
    let { visualElement: i } = a.options;
    (i && i.props.style && i.props.style.display === `contents`) ||
      (r &&
        a.options.layoutScroll &&
        a.scroll &&
        a !== a.root &&
        ki(e, { x: -a.scroll.offset.x, y: -a.scroll.offset.y }),
      o && ((t.x *= o.x.scale), (t.y *= o.y.scale), Ti(e, o)),
      r && yi(a.latestValues) && ki(e, a.latestValues));
  }
  (t.x < xd && t.x > bd && (t.x = 1), t.y < xd && t.y > bd && (t.y = 1));
}
function Di(e, t) {
  ((e.min += t), (e.max += t));
}
function Oi(e, t, n, r, i = 0.5) {
  wi(e, t, n, K(e.min, e.max, i), r);
}
function ki(e, t) {
  (Oi(e.x, t.x, t.scaleX, t.scale, t.originX), Oi(e.y, t.y, t.scaleY, t.scale, t.originY));
}
function Ai(e, t) {
  return mi(gi(e.getBoundingClientRect(), t));
}
function ji(e, t, n) {
  let r = Ai(e, n),
    { scroll: i } = t;
  return (i && (Di(r.x, i.offset.x), Di(r.y, i.offset.y)), r);
}
function Mi(e, { style: t, vars: n }, r, i) {
  let a = e.style,
    o;
  for (o in t) a[o] = t[o];
  for (o in (i?.applyProjectionStyles(a, r), n)) a.setProperty(o, n[o]);
}
function Ni(e) {
  return o.getComputedStyle(e);
}
function Pi(e, t, n, r) {
  for (let n in (Mi(e, t, void 0, r), t.attrs)) e.setAttribute(wd.has(n) ? n : Au(n), t.attrs[n]);
}
function O(e) {
  return [e(`x`), e(`y`)];
}
function Fi(e, t) {
  return t ? { point: t(e.point) } : e;
}
function Ii(e, t) {
  return { x: e.x - t.x, y: e.y - t.y };
}
function Li({ point: e }, t) {
  return { point: e, delta: Ii(e, zi(t)), offset: Ii(e, Ri(t)), velocity: Bi(t, 0.1) };
}
function Ri(e) {
  return e[0];
}
function zi(e) {
  return e[e.length - 1];
}
function Bi(e, t) {
  if (e.length < 2) return { x: 0, y: 0 };
  let n = e.length - 1,
    r = null,
    i = zi(e);
  for (; n >= 0 && ((r = e[n]), !(i.timestamp - r.timestamp > P(t))); ) n--;
  if (!r) return { x: 0, y: 0 };
  let a = F(i.timestamp - r.timestamp);
  if (a === 0) return { x: 0, y: 0 };
  let o = { x: (i.x - r.x) / a, y: (i.y - r.y) / a };
  return (o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o);
}
function Vi(e, { min: t, max: n }, r) {
  return (
    t !== void 0 && e < t
      ? (e = r ? K(t, e, r.min) : Math.max(e, t))
      : n !== void 0 && e > n && (e = r ? K(n, e, r.max) : Math.min(e, n)),
    e
  );
}
function Hi(e, t, n) {
  return {
    min: t === void 0 ? void 0 : e.min + t,
    max: n === void 0 ? void 0 : e.max + n - (e.max - e.min),
  };
}
function Ui(e, { top: t, left: n, bottom: r, right: i }) {
  return { x: Hi(e.x, n, i), y: Hi(e.y, t, r) };
}
function Wi(e, t) {
  let n = t.min - e.min,
    r = t.max - e.max;
  return (t.max - t.min < e.max - e.min && ([n, r] = [r, n]), { min: n, max: r });
}
function Gi(e, t) {
  return { x: Wi(e.x, t.x), y: Wi(e.y, t.y) };
}
function Ki(e, t) {
  let n = 0.5,
    r = D(e),
    i = D(t);
  return (
    i > r ? (n = vs(t.min, t.max - r, e.min)) : r > i && (n = vs(e.min, e.max - i, t.min)),
    A(0, 1, n)
  );
}
function qi(e, t) {
  let n = {};
  return (
    t.min !== void 0 && (n.min = t.min - e.min),
    t.max !== void 0 && (n.max = t.max - e.min),
    n
  );
}
function Ji(e = kd) {
  return (
    e === !1 ? (e = 0) : e === !0 && (e = kd),
    { x: Yi(e, `left`, `right`), y: Yi(e, `top`, `bottom`) }
  );
}
function Yi(e, t, n) {
  return { min: Xi(e, t), max: Xi(e, n) };
}
function Xi(e, t) {
  return typeof e == `number` ? e : e[t] || 0;
}
function Zi(e, t, n) {
  return (t === !0 || t === e) && (n === null || n === e);
}
function Qi(e, t = 10) {
  let n = null;
  return (Math.abs(e.y) > t ? (n = `y`) : Math.abs(e.x) > t && (n = `x`), n);
}
function $i(e) {
  let [t, n] = Rn(),
    r = u(ls);
  return _(Ld, { ...e, layoutGroup: r, switchLayoutGroup: u(Nu), isPresent: t, safeToRemove: n });
}
function ea(e, t, n) {
  let r = X(e) ? e : T(e);
  return (r.start(id(``, r, t, n)), r.animation);
}
function ta(e, t, n, r, i, a) {
  i
    ? ((e.opacity = K(0, n.opacity ?? 1, Wd(r))), (e.opacityExit = K(t.opacity ?? 1, 0, Gd(r))))
    : a && (e.opacity = K(t.opacity ?? 1, n.opacity ?? 1, r));
  for (let i = 0; i < Vd; i++) {
    let a = `border${Bd[i]}Radius`,
      o = na(t, a),
      s = na(n, a);
    (o === void 0 && s === void 0) ||
      ((o ||= 0),
      (s ||= 0),
      o === 0 || s === 0 || Ud(o) === Ud(s)
        ? ((e[a] = Math.max(K(Hd(o), Hd(s), r), 0)), (H.test(s) || H.test(o)) && (e[a] += `%`))
        : (e[a] = s));
  }
  (t.rotate || n.rotate) && (e.rotate = K(t.rotate || 0, n.rotate || 0, r));
}
function na(e, t) {
  return e[t] === void 0 ? e.borderRadius : e[t];
}
function ra(e, t, n) {
  return (r) => (r < e ? 0 : r > t ? 1 : n(vs(e, t, r)));
}
function ia(e, t) {
  ((e.min = t.min), (e.max = t.max));
}
function k(e, t) {
  (ia(e.x, t.x), ia(e.y, t.y));
}
function aa(e, t) {
  ((e.translate = t.translate),
    (e.scale = t.scale),
    (e.originPoint = t.originPoint),
    (e.origin = t.origin));
}
function oa(e, t, n, r, i) {
  return ((e -= t), (e = Si(e, 1 / n, r)), i !== void 0 && (e = Si(e, 1 / i, r)), e);
}
function sa(e, t = 0, n = 1, r = 0.5, i, a = e, o = e) {
  if (
    (H.test(t) && ((t = parseFloat(t)), (t = K(o.min, o.max, t / 100) - o.min)),
    typeof t != `number`)
  )
    return;
  let s = K(a.min, a.max, r);
  (e === a && (s -= t), (e.min = oa(e.min, t, n, s, i)), (e.max = oa(e.max, t, n, s, i)));
}
function ca(e, t, [n, r, i], a, o) {
  sa(e, t[n], t[r], t[i], t.scale, a, o);
}
function la(e, t, n, r) {
  (ca(e.x, t, Kd, n ? n.x : void 0, r ? r.x : void 0),
    ca(e.y, t, qd, n ? n.y : void 0, r ? r.y : void 0));
}
function ua(e) {
  return e.translate === 0 && e.scale === 1;
}
function da(e) {
  return ua(e.x) && ua(e.y);
}
function fa(e, t) {
  return e.min === t.min && e.max === t.max;
}
function pa(e, t) {
  return fa(e.x, t.x) && fa(e.y, t.y);
}
function ma(e, t) {
  return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max);
}
function ha(e, t) {
  return ma(e.x, t.x) && ma(e.y, t.y);
}
function ga(e) {
  return D(e.x) / D(e.y);
}
function _a(e, t) {
  return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint;
}
function va(e, t, n) {
  let r = ``,
    i = e.x.translate / t.x,
    a = e.y.translate / t.y,
    o = n?.z || 0;
  if (
    ((i || a || o) && (r = `translate3d(${i}px, ${a}px, ${o}px) `),
    (t.x !== 1 || t.y !== 1) && (r += `scale(${1 / t.x}, ${1 / t.y}) `),
    n)
  ) {
    let { transformPerspective: e, rotate: t, rotateX: i, rotateY: a, skewX: o, skewY: s } = n;
    (e && (r = `perspective(${e}px) ${r}`),
      t && (r += `rotate(${t}deg) `),
      i && (r += `rotateX(${i}deg) `),
      a && (r += `rotateY(${a}deg) `),
      o && (r += `skewX(${o}deg) `),
      s && (r += `skewY(${s}deg) `));
  }
  let s = e.x.scale * t.x,
    c = e.y.scale * t.y;
  return ((s !== 1 || c !== 1) && (r += `scale(${s}, ${c})`), r || `none`);
}
function ya(e, t, n, r) {
  let { latestValues: i } = t;
  i[e] && ((n[e] = i[e]), t.setStaticValue(e, 0), r && (r[e] = 0));
}
function ba(e) {
  if (((e.hasCheckedOptimisedAppear = !0), e.root === e)) return;
  let { visualElement: t } = e.options;
  if (!t) return;
  let n = Br(t);
  if (o.MotionHasOptimisedAnimation(n, `transform`)) {
    let { layout: t, layoutId: r } = e.options;
    o.MotionCancelOptimisedAnimation(n, `transform`, L, !(t || r));
  }
  let { parent: r } = e;
  r && !r.hasCheckedOptimisedAppear && ba(r);
}
function xa({
  attachResizeListener: e,
  defaultParent: t,
  measureScroll: n,
  checkIsScrollRoot: r,
  resetTransform: i,
}) {
  return class {
    constructor(e = {}, n = t?.()) {
      ((this.id = Qd++),
        (this.animationId = 0),
        (this.animationCommitId = 0),
        (this.children = new Set()),
        (this.options = {}),
        (this.isTreeAnimating = !1),
        (this.isAnimationBlocked = !1),
        (this.isLayoutDirty = !1),
        (this.isProjectionDirty = !1),
        (this.isSharedProjectionDirty = !1),
        (this.isTransformDirty = !1),
        (this.updateManuallyBlocked = !1),
        (this.updateBlockedByResize = !1),
        (this.isUpdating = !1),
        (this.isSVG = !1),
        (this.needsReset = !1),
        (this.shouldResetTransform = !1),
        (this.hasCheckedOptimisedAppear = !1),
        (this.treeScale = { x: 1, y: 1 }),
        (this.eventHandlers = new Map()),
        (this.hasTreeAnimated = !1),
        (this.layoutVersion = 0),
        (this.updateScheduled = !1),
        (this.scheduleUpdate = () => this.update()),
        (this.projectionUpdateScheduled = !1),
        (this.checkUpdateFailed = () => {
          this.isUpdating && ((this.isUpdating = !1), this.clearAllSnapshots());
        }),
        (this.updateProjection = () => {
          ((this.projectionUpdateScheduled = !1),
            I.value && (Yd.nodes = Yd.calculatedTargetDeltas = Yd.calculatedProjections = 0),
            this.nodes.forEach(wa),
            this.nodes.forEach(ja),
            this.nodes.forEach(Ma),
            this.nodes.forEach(Ta),
            I.addProjectionMetrics && I.addProjectionMetrics(Yd));
        }),
        (this.resolvedRelativeTargetAt = 0),
        (this.linkedParentVersion = 0),
        (this.hasProjected = !1),
        (this.isVisible = !0),
        (this.animationProgress = 0),
        (this.sharedNodes = new Map()),
        (this.latestValues = e),
        (this.root = n ? n.root || n : this),
        (this.path = n ? [...n.path, n] : []),
        (this.parent = n),
        (this.depth = n ? n.depth + 1 : 0));
      for (let e = 0; e < this.path.length; e++) this.path[e].shouldResetTransform = !0;
      this.root === this && (this.nodes = new zd());
    }
    addEventListener(e, t) {
      return (
        this.eventHandlers.has(e) || this.eventHandlers.set(e, new ys()),
        this.eventHandlers.get(e).add(t)
      );
    }
    notifyListeners(e, ...t) {
      let n = this.eventHandlers.get(e);
      n && n.notify(...t);
    }
    hasListeners(e) {
      return this.eventHandlers.has(e);
    }
    mount(t) {
      if (this.instance) return;
      ((this.isSVG = hn(t) && !wn(t)), (this.instance = t));
      let { layoutId: n, layout: r, visualElement: i } = this.options;
      if (
        (i && !i.current && i.mount(t),
        this.root.nodes.add(this),
        this.parent && this.parent.children.add(this),
        this.root.hasTreeAnimated && (r || n) && (this.isLayoutDirty = !0),
        e)
      ) {
        let n,
          r = 0,
          i = () => (this.root.updateBlockedByResize = !1);
        (L.read(() => {
          r = o.innerWidth;
        }),
          e(t, () => {
            let e = o.innerWidth;
            e !== r &&
              ((r = e),
              (this.root.updateBlockedByResize = !0),
              n && n(),
              (n = pi(i, 250)),
              Fd.hasAnimatedSinceResize &&
                ((Fd.hasAnimatedSinceResize = !1), this.nodes.forEach(Aa)));
          }));
      }
      (n && this.root.registerSharedNode(n, this),
        this.options.animate !== !1 &&
          i &&
          (n || r) &&
          this.addEventListener(
            `didUpdate`,
            ({ delta: e, hasLayoutChanged: t, hasRelativeLayoutChanged: n, layout: r }) => {
              if (this.isTreeAnimationBlocked()) {
                ((this.target = void 0), (this.relativeTarget = void 0));
                return;
              }
              let a = this.options.transition || i.getDefaultTransition() || $d,
                { onLayoutAnimationStart: o, onLayoutAnimationComplete: s } = i.getProps(),
                c = !this.targetLayout || !ha(this.targetLayout, r),
                l = !t && n;
              if (
                this.options.layoutRoot ||
                this.resumeFrom ||
                l ||
                (t && (c || !this.currentAnimation))
              ) {
                this.resumeFrom &&
                  ((this.resumingFrom = this.resumeFrom),
                  (this.resumingFrom.resumingFrom = void 0));
                let t = { ...Zt(a, `layout`), onPlay: o, onComplete: s };
                ((i.shouldReduceMotion || this.options.layoutRoot) &&
                  ((t.delay = 0), (t.type = !1)),
                  this.startAnimation(t),
                  this.setAnimationOrigin(e, l));
              } else
                (t || Aa(this),
                  this.isLead() && this.options.onExitComplete && this.options.onExitComplete());
              this.targetLayout = r;
            }
          ));
    }
    unmount() {
      (this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this));
      let e = this.getStack();
      (e && e.remove(this),
        this.parent && this.parent.children.delete(this),
        (this.instance = void 0),
        this.eventHandlers.clear(),
        R(this.updateProjection));
    }
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || (this.parent && this.parent.isTreeAnimationBlocked()) || !1;
    }
    startUpdate() {
      this.isUpdateBlocked() ||
        ((this.isUpdating = !0), this.nodes && this.nodes.forEach(Na), this.animationId++);
    }
    getTransformTemplate() {
      let { visualElement: e } = this.options;
      return e && e.getProps().transformTemplate;
    }
    willUpdate(e = !0) {
      if (((this.root.hasTreeAnimated = !0), this.root.isUpdateBlocked())) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (
        (o.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && ba(this),
        !this.root.isUpdating && this.root.startUpdate(),
        this.isLayoutDirty)
      )
        return;
      this.isLayoutDirty = !0;
      for (let e = 0; e < this.path.length; e++) {
        let t = this.path[e];
        ((t.shouldResetTransform = !0),
          t.updateScroll(`snapshot`),
          t.options.layoutRoot && t.willUpdate(!1));
      }
      let { layoutId: t, layout: n } = this.options;
      if (t === void 0 && !n) return;
      let r = this.getTransformTemplate();
      ((this.prevTransformTemplateValue = r ? r(this.latestValues, ``) : void 0),
        this.updateSnapshot(),
        e && this.notifyListeners(`willUpdate`));
    }
    update() {
      if (((this.updateScheduled = !1), this.isUpdateBlocked())) {
        (this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(Da));
        return;
      }
      if (this.animationId <= this.animationCommitId) {
        this.nodes.forEach(Oa);
        return;
      }
      ((this.animationCommitId = this.animationId),
        this.isUpdating
          ? ((this.isUpdating = !1),
            this.nodes.forEach(ka),
            this.nodes.forEach(Sa),
            this.nodes.forEach(Ca))
          : this.nodes.forEach(Oa),
        this.clearAllSnapshots());
      let e = B.now();
      ((z.delta = A(0, 1e3 / 60, e - z.timestamp)),
        (z.timestamp = e),
        (z.isProcessing = !0),
        Us.update.process(z),
        Us.preRender.process(z),
        Us.render.process(z),
        (z.isProcessing = !1));
    }
    didUpdate() {
      this.updateScheduled || ((this.updateScheduled = !0), Gl.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      (this.nodes.forEach(Ea), this.sharedNodes.forEach(Pa));
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled ||
        ((this.projectionUpdateScheduled = !0), L.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      L.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    updateSnapshot() {
      this.snapshot ||
        !this.instance ||
        ((this.snapshot = this.measure()),
        this.snapshot &&
          !D(this.snapshot.measuredBox.x) &&
          !D(this.snapshot.measuredBox.y) &&
          (this.snapshot = void 0));
    }
    updateLayout() {
      if (
        !this.instance ||
        (this.updateScroll(),
        !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)
      )
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let e = 0; e < this.path.length; e++) this.path[e].updateScroll();
      let e = this.layout;
      ((this.layout = this.measure(!1)),
        this.layoutVersion++,
        (this.layoutCorrected = Q()),
        (this.isLayoutDirty = !1),
        (this.projectionDelta = void 0),
        this.notifyListeners(`measure`, this.layout.layoutBox));
      let { visualElement: t } = this.options;
      t && t.notify(`LayoutMeasure`, this.layout.layoutBox, e ? e.layoutBox : void 0);
    }
    updateScroll(e = `measure`) {
      let t = !!(this.options.layoutScroll && this.instance);
      if (
        (this.scroll &&
          this.scroll.animationId === this.root.animationId &&
          this.scroll.phase === e &&
          (t = !1),
        t && this.instance)
      ) {
        let t = r(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: e,
          isRoot: t,
          offset: n(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : t,
        };
      }
    }
    resetTransform() {
      if (!i) return;
      let e = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout,
        t = this.projectionDelta && !da(this.projectionDelta),
        n = this.getTransformTemplate(),
        r = n ? n(this.latestValues, ``) : void 0,
        a = r !== this.prevTransformTemplateValue;
      e &&
        this.instance &&
        (t || yi(this.latestValues) || a) &&
        (i(this.instance, r), (this.shouldResetTransform = !1), this.scheduleRender());
    }
    measure(e = !0) {
      let t = this.measurePageBox(),
        n = this.removeElementScroll(t);
      return (
        e && (n = this.removeTransform(n)),
        Ba(n),
        {
          animationId: this.root.animationId,
          measuredBox: t,
          layoutBox: n,
          latestValues: {},
          source: this.id,
        }
      );
    }
    measurePageBox() {
      let { visualElement: e } = this.options;
      if (!e) return Q();
      let t = e.measureViewportBox();
      if (!(this.scroll?.wasRoot || this.path.some(Ha))) {
        let { scroll: e } = this.root;
        e && (Di(t.x, e.offset.x), Di(t.y, e.offset.y));
      }
      return t;
    }
    removeElementScroll(e) {
      let t = Q();
      if ((k(t, e), this.scroll?.wasRoot)) return t;
      for (let n = 0; n < this.path.length; n++) {
        let r = this.path[n],
          { scroll: i, options: a } = r;
        r !== this.root &&
          i &&
          a.layoutScroll &&
          (i.wasRoot && k(t, e), Di(t.x, i.offset.x), Di(t.y, i.offset.y));
      }
      return t;
    }
    applyTransform(e, t = !1) {
      let n = Q();
      k(n, e);
      for (let e = 0; e < this.path.length; e++) {
        let r = this.path[e];
        (!t &&
          r.options.layoutScroll &&
          r.scroll &&
          r !== r.root &&
          ki(n, { x: -r.scroll.offset.x, y: -r.scroll.offset.y }),
          yi(r.latestValues) && ki(n, r.latestValues));
      }
      return (yi(this.latestValues) && ki(n, this.latestValues), n);
    }
    removeTransform(e) {
      let t = Q();
      k(t, e);
      for (let e = 0; e < this.path.length; e++) {
        let n = this.path[e];
        if (!n.instance || !yi(n.latestValues)) continue;
        vi(n.latestValues) && n.updateSnapshot();
        let r = Q();
        (k(r, n.measurePageBox()),
          la(t, n.latestValues, n.snapshot ? n.snapshot.layoutBox : void 0, r));
      }
      return (yi(this.latestValues) && la(t, this.latestValues), t);
    }
    setTargetDelta(e) {
      ((this.targetDelta = e), this.root.scheduleUpdateProjection(), (this.isProjectionDirty = !0));
    }
    setOptions(e) {
      this.options = {
        ...this.options,
        ...e,
        crossfade: e.crossfade === void 0 ? !0 : e.crossfade,
      };
    }
    clearMeasurements() {
      ((this.scroll = void 0),
        (this.layout = void 0),
        (this.snapshot = void 0),
        (this.prevTransformTemplateValue = void 0),
        (this.targetDelta = void 0),
        (this.target = void 0),
        (this.isLayoutDirty = !1));
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent &&
        this.relativeParent.resolvedRelativeTargetAt !== z.timestamp &&
        this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(e = !1) {
      let t = this.getLead();
      ((this.isProjectionDirty ||= t.isProjectionDirty),
        (this.isTransformDirty ||= t.isTransformDirty),
        (this.isSharedProjectionDirty ||= t.isSharedProjectionDirty));
      let n = !!this.resumingFrom || this !== t;
      if (
        !(
          e ||
          (n && this.isSharedProjectionDirty) ||
          this.isProjectionDirty ||
          this.parent?.isProjectionDirty ||
          this.attemptToResolveRelativeTarget ||
          this.root.updateBlockedByResize
        )
      )
        return;
      let { layout: r, layoutId: i } = this.options;
      if (!this.layout || !(r || i)) return;
      this.resolvedRelativeTargetAt = z.timestamp;
      let a = this.getClosestProjectingParent();
      (a &&
        this.linkedParentVersion !== a.layoutVersion &&
        !a.options.layoutRoot &&
        this.removeRelativeTarget(),
        !this.targetDelta &&
          !this.relativeTarget &&
          (a && a.layout
            ? this.createRelativeTarget(a, this.layout.layoutBox, a.layout.layoutBox)
            : this.removeRelativeTarget()),
        !(!this.relativeTarget && !this.targetDelta) &&
          (this.target || ((this.target = Q()), (this.targetWithTransforms = Q())),
          this.relativeTarget &&
          this.relativeTargetOrigin &&
          this.relativeParent &&
          this.relativeParent.target
            ? (this.forceRelativeParentToResolveTarget(),
              li(this.target, this.relativeTarget, this.relativeParent.target))
            : this.targetDelta
              ? (this.resumingFrom
                  ? (this.target = this.applyTransform(this.layout.layoutBox))
                  : k(this.target, this.layout.layoutBox),
                Ti(this.target, this.targetDelta))
              : k(this.target, this.layout.layoutBox),
          this.attemptToResolveRelativeTarget &&
            ((this.attemptToResolveRelativeTarget = !1),
            a &&
            !!a.resumingFrom == !!this.resumingFrom &&
            !a.options.layoutScroll &&
            a.target &&
            this.animationProgress !== 1
              ? this.createRelativeTarget(a, this.target, a.target)
              : (this.relativeParent = this.relativeTarget = void 0)),
          I.value && Yd.calculatedTargetDeltas++));
    }
    getClosestProjectingParent() {
      if (!(!this.parent || vi(this.parent.latestValues) || bi(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!(
        (this.relativeTarget || this.targetDelta || this.options.layoutRoot) &&
        this.layout
      );
    }
    createRelativeTarget(e, t, n) {
      ((this.relativeParent = e),
        (this.linkedParentVersion = e.layoutVersion),
        this.forceRelativeParentToResolveTarget(),
        (this.relativeTarget = Q()),
        (this.relativeTargetOrigin = Q()),
        di(this.relativeTargetOrigin, t, n),
        k(this.relativeTarget, this.relativeTargetOrigin));
    }
    removeRelativeTarget() {
      this.relativeParent = this.relativeTarget = void 0;
    }
    calcProjection() {
      let e = this.getLead(),
        t = !!this.resumingFrom || this !== e,
        n = !0;
      if (
        ((this.isProjectionDirty || this.parent?.isProjectionDirty) && (n = !1),
        t && (this.isSharedProjectionDirty || this.isTransformDirty) && (n = !1),
        this.resolvedRelativeTargetAt === z.timestamp && (n = !1),
        n)
      )
        return;
      let { layout: r, layoutId: i } = this.options;
      if (
        ((this.isTreeAnimating = !!(
          (this.parent && this.parent.isTreeAnimating) ||
          this.currentAnimation ||
          this.pendingAnimation
        )),
        this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0),
        !this.layout || !(r || i))
      )
        return;
      k(this.layoutCorrected, this.layout.layoutBox);
      let a = this.treeScale.x,
        o = this.treeScale.y;
      (Ei(this.layoutCorrected, this.treeScale, this.path, t),
        e.layout &&
          !e.target &&
          (this.treeScale.x !== 1 || this.treeScale.y !== 1) &&
          ((e.target = e.layout.layoutBox), (e.targetWithTransforms = Q())));
      let { target: s } = e;
      if (!s) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      (!this.projectionDelta || !this.prevProjectionDelta
        ? this.createProjectionDeltas()
        : (aa(this.prevProjectionDelta.x, this.projectionDelta.x),
          aa(this.prevProjectionDelta.y, this.projectionDelta.y)),
        si(this.projectionDelta, this.layoutCorrected, s, this.latestValues),
        (this.treeScale.x !== a ||
          this.treeScale.y !== o ||
          !_a(this.projectionDelta.x, this.prevProjectionDelta.x) ||
          !_a(this.projectionDelta.y, this.prevProjectionDelta.y)) &&
          ((this.hasProjected = !0),
          this.scheduleRender(),
          this.notifyListeners(`projectionUpdate`, s)),
        I.value && Yd.calculatedProjections++);
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(e = !0) {
      if ((this.options.visualElement?.scheduleRender(), e)) {
        let e = this.getStack();
        e && e.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      ((this.prevProjectionDelta = Wu()),
        (this.projectionDelta = Wu()),
        (this.projectionDeltaWithTransform = Wu()));
    }
    setAnimationOrigin(e, t = !1) {
      let n = this.snapshot,
        r = n ? n.latestValues : {},
        i = { ...this.latestValues },
        a = Wu();
      ((!this.relativeParent || !this.relativeParent.options.layoutRoot) &&
        (this.relativeTarget = this.relativeTargetOrigin = void 0),
        (this.attemptToResolveRelativeTarget = !t));
      let o = Q(),
        s = (n ? n.source : void 0) !== (this.layout ? this.layout.source : void 0),
        c = this.getStack(),
        l = !c || c.members.length <= 1,
        u = !!(s && !l && this.options.crossfade === !0 && !this.path.some(Ra));
      this.animationProgress = 0;
      let d;
      ((this.mixTargetDelta = (t) => {
        let n = t / 1e3;
        (Fa(a.x, e.x, n),
          Fa(a.y, e.y, n),
          this.setTargetDelta(a),
          this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.layout &&
            this.relativeParent &&
            this.relativeParent.layout &&
            (di(o, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
            La(this.relativeTarget, this.relativeTargetOrigin, o, n),
            d && pa(this.relativeTarget, d) && (this.isProjectionDirty = !1),
            (d ||= Q()),
            k(d, this.relativeTarget)),
          s && ((this.animationValues = i), ta(i, r, this.latestValues, n, u, l)),
          this.root.scheduleUpdateProjection(),
          this.scheduleRender(),
          (this.animationProgress = n));
      }),
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0));
    }
    startAnimation(e) {
      (this.notifyListeners(`animationStart`),
        this.currentAnimation?.stop(),
        this.resumingFrom?.currentAnimation?.stop(),
        (this.pendingAnimation &&= (R(this.pendingAnimation), void 0)),
        (this.pendingAnimation = L.update(() => {
          ((Fd.hasAnimatedSinceResize = !0),
            Gs.layout++,
            (this.motionValue ||= T(0)),
            (this.currentAnimation = ea(this.motionValue, [0, 1e3], {
              ...e,
              velocity: 0,
              isSync: !0,
              onUpdate: (t) => {
                (this.mixTargetDelta(t), e.onUpdate && e.onUpdate(t));
              },
              onStop: () => {
                Gs.layout--;
              },
              onComplete: () => {
                (Gs.layout--, e.onComplete && e.onComplete(), this.completeAnimation());
              },
            })),
            this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation),
            (this.pendingAnimation = void 0));
        })));
    }
    completeAnimation() {
      this.resumingFrom &&
        ((this.resumingFrom.currentAnimation = void 0),
        (this.resumingFrom.preserveOpacity = void 0));
      let e = this.getStack();
      (e && e.exitAnimationComplete(),
        (this.resumingFrom = this.currentAnimation = this.animationValues = void 0),
        this.notifyListeners(`animationComplete`));
    }
    finishAnimation() {
      (this.currentAnimation &&
        (this.mixTargetDelta && this.mixTargetDelta(Zd), this.currentAnimation.stop()),
        this.completeAnimation());
    }
    applyTransformsToTarget() {
      let e = this.getLead(),
        { targetWithTransforms: t, target: n, layout: r, latestValues: i } = e;
      if (!(!t || !n || !r)) {
        if (
          this !== e &&
          this.layout &&
          r &&
          Va(this.options.animationType, this.layout.layoutBox, r.layoutBox)
        ) {
          n = this.target || Q();
          let t = D(this.layout.layoutBox.x);
          ((n.x.min = e.target.x.min), (n.x.max = n.x.min + t));
          let r = D(this.layout.layoutBox.y);
          ((n.y.min = e.target.y.min), (n.y.max = n.y.min + r));
        }
        (k(t, n), ki(t, i), si(this.projectionDeltaWithTransform, this.layoutCorrected, t, i));
      }
    }
    registerSharedNode(e, t) {
      (this.sharedNodes.has(e) || this.sharedNodes.set(e, new Jd()),
        this.sharedNodes.get(e).add(t));
      let n = t.options.initialPromotionConfig;
      t.promote({
        transition: n ? n.transition : void 0,
        preserveFollowOpacity:
          n && n.shouldPreserveFollowOpacity ? n.shouldPreserveFollowOpacity(t) : void 0,
      });
    }
    isLead() {
      let e = this.getStack();
      return e ? e.lead === this : !0;
    }
    getLead() {
      let { layoutId: e } = this.options;
      return (e && this.getStack()?.lead) || this;
    }
    getPrevLead() {
      let { layoutId: e } = this.options;
      return e ? this.getStack()?.prevLead : void 0;
    }
    getStack() {
      let { layoutId: e } = this.options;
      if (e) return this.root.sharedNodes.get(e);
    }
    promote({ needsReset: e, transition: t, preserveFollowOpacity: n } = {}) {
      let r = this.getStack();
      (r && r.promote(this, n),
        e && ((this.projectionDelta = void 0), (this.needsReset = !0)),
        t && this.setOptions({ transition: t }));
    }
    relegate() {
      let e = this.getStack();
      return e ? e.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      let { visualElement: e } = this.options;
      if (!e) return;
      let t = !1,
        { latestValues: n } = e;
      if (
        ((n.z || n.rotate || n.rotateX || n.rotateY || n.rotateZ || n.skewX || n.skewY) && (t = !0),
        !t)
      )
        return;
      let r = {};
      n.z && ya(`z`, e, r, this.animationValues);
      for (let t = 0; t < Xd.length; t++)
        (ya(`rotate${Xd[t]}`, e, r, this.animationValues),
          ya(`skew${Xd[t]}`, e, r, this.animationValues));
      for (let t in (e.render(), r))
        (e.setStaticValue(t, r[t]), this.animationValues && (this.animationValues[t] = r[t]));
      e.scheduleRender();
    }
    applyProjectionStyles(e, t) {
      if (!this.instance || this.isSVG) return;
      if (!this.isVisible) {
        e.visibility = `hidden`;
        return;
      }
      let n = this.getTransformTemplate();
      if (this.needsReset) {
        ((this.needsReset = !1),
          (e.visibility = ``),
          (e.opacity = ``),
          (e.pointerEvents = Zn(t?.pointerEvents) || ``),
          (e.transform = n ? n(this.latestValues, ``) : `none`));
        return;
      }
      let r = this.getLead();
      if (!this.projectionDelta || !this.layout || !r.target) {
        (this.options.layoutId &&
          ((e.opacity = this.latestValues.opacity === void 0 ? 1 : this.latestValues.opacity),
          (e.pointerEvents = Zn(t?.pointerEvents) || ``)),
          this.hasProjected &&
            !yi(this.latestValues) &&
            ((e.transform = n ? n({}, ``) : `none`), (this.hasProjected = !1)));
        return;
      }
      e.visibility = ``;
      let i = r.animationValues || r.latestValues;
      this.applyTransformsToTarget();
      let a = va(this.projectionDeltaWithTransform, this.treeScale, i);
      (n && (a = n(i, a)), (e.transform = a));
      let { x: o, y: s } = this.projectionDelta;
      for (let t in ((e.transformOrigin = `${o.origin * 100}% ${s.origin * 100}% 0`),
      r.animationValues
        ? (e.opacity =
            r === this
              ? (i.opacity ?? this.latestValues.opacity ?? 1)
              : this.preserveOpacity
                ? this.latestValues.opacity
                : i.opacityExit)
        : (e.opacity =
            r === this
              ? i.opacity === void 0
                ? ``
                : i.opacity
              : i.opacityExit === void 0
                ? 0
                : i.opacityExit),
      wu)) {
        if (i[t] === void 0) continue;
        let { correct: n, applyTo: o, isCSSVariable: s } = wu[t],
          c = a === `none` ? i[t] : n(i[t], r);
        if (o) {
          let t = o.length;
          for (let n = 0; n < t; n++) e[o[n]] = c;
        } else s ? (this.options.visualElement.renderState.vars[t] = c) : (e[t] = c);
      }
      this.options.layoutId && (e.pointerEvents = r === this ? Zn(t?.pointerEvents) || `` : `none`);
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    resetTree() {
      (this.root.nodes.forEach((e) => e.currentAnimation?.stop()),
        this.root.nodes.forEach(Da),
        this.root.sharedNodes.clear());
    }
  };
}
function Sa(e) {
  e.updateLayout();
}
function Ca(e) {
  let t = e.resumeFrom?.snapshot || e.snapshot;
  if (e.isLead() && e.layout && t && e.hasListeners(`didUpdate`)) {
    let { layoutBox: n, measuredBox: r } = e.layout,
      { animationType: i } = e.options,
      a = t.source !== e.layout.source;
    i === `size`
      ? O((e) => {
          let r = a ? t.measuredBox[e] : t.layoutBox[e],
            i = D(r);
          ((r.min = n[e].min), (r.max = r.min + i));
        })
      : Va(i, t.layoutBox, n) &&
        O((r) => {
          let i = a ? t.measuredBox[r] : t.layoutBox[r],
            o = D(n[r]);
          ((i.max = i.min + o),
            e.relativeTarget &&
              !e.currentAnimation &&
              ((e.isProjectionDirty = !0),
              (e.relativeTarget[r].max = e.relativeTarget[r].min + o)));
        });
    let o = Wu();
    si(o, n, t.layoutBox);
    let s = Wu();
    a ? si(s, e.applyTransform(r, !0), t.measuredBox) : si(s, n, t.layoutBox);
    let c = !da(o),
      l = !1;
    if (!e.resumeFrom) {
      let r = e.getClosestProjectingParent();
      if (r && !r.resumeFrom) {
        let { snapshot: i, layout: a } = r;
        if (i && a) {
          let o = Q();
          di(o, t.layoutBox, i.layoutBox);
          let s = Q();
          (di(s, n, a.layoutBox),
            ha(o, s) || (l = !0),
            r.options.layoutRoot &&
              ((e.relativeTarget = s), (e.relativeTargetOrigin = o), (e.relativeParent = r)));
        }
      }
    }
    e.notifyListeners(`didUpdate`, {
      layout: n,
      snapshot: t,
      delta: s,
      layoutDelta: o,
      hasLayoutChanged: c,
      hasRelativeLayoutChanged: l,
    });
  } else if (e.isLead()) {
    let { onExitComplete: t } = e.options;
    t && t();
  }
  e.options.transition = void 0;
}
function wa(e) {
  (I.value && Yd.nodes++,
    e.parent &&
      (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty),
      (e.isSharedProjectionDirty ||= !!(
        e.isProjectionDirty ||
        e.parent.isProjectionDirty ||
        e.parent.isSharedProjectionDirty
      )),
      (e.isTransformDirty ||= e.parent.isTransformDirty)));
}
function Ta(e) {
  e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1;
}
function Ea(e) {
  e.clearSnapshot();
}
function Da(e) {
  e.clearMeasurements();
}
function Oa(e) {
  e.isLayoutDirty = !1;
}
function ka(e) {
  let { visualElement: t } = e.options;
  (t && t.getProps().onBeforeLayoutMeasure && t.notify(`BeforeLayoutMeasure`), e.resetTransform());
}
function Aa(e) {
  (e.finishAnimation(),
    (e.targetDelta = e.relativeTarget = e.target = void 0),
    (e.isProjectionDirty = !0));
}
function ja(e) {
  e.resolveTargetDelta();
}
function Ma(e) {
  e.calcProjection();
}
function Na(e) {
  e.resetSkewAndRotation();
}
function Pa(e) {
  e.removeLeadSnapshot();
}
function Fa(e, t, n) {
  ((e.translate = K(t.translate, 0, n)),
    (e.scale = K(t.scale, 1, n)),
    (e.origin = t.origin),
    (e.originPoint = t.originPoint));
}
function Ia(e, t, n, r) {
  ((e.min = K(t.min, n.min, r)), (e.max = K(t.max, n.max, r)));
}
function La(e, t, n, r) {
  (Ia(e.x, t.x, n.x, r), Ia(e.y, t.y, n.y, r));
}
function Ra(e) {
  return e.animationValues && e.animationValues.opacityExit !== void 0;
}
function za(e) {
  ((e.min = tf(e.min)), (e.max = tf(e.max)));
}
function Ba(e) {
  (za(e.x), za(e.y));
}
function Va(e, t, n) {
  return e === `position` || (e === `preserve-aspect` && !ai(ga(t), ga(n), 0.2));
}
function Ha(e) {
  return e !== e.root && e.scroll?.wasRoot;
}
function Ua(e, t, n) {
  let { props: r } = e;
  e.animationState && r.whileHover && e.animationState.setActive(`whileHover`, n === `Start`);
  let i = r[`onHover` + n];
  i && L.postRender(() => i(t, ni(t)));
}
function Wa(e, t, n) {
  let { props: r } = e;
  if (e.current instanceof HTMLButtonElement && e.current.disabled) return;
  e.animationState && r.whileTap && e.animationState.setActive(`whileTap`, n === `Start`);
  let i = r[`onTap` + (n === `End` ? `` : n)];
  i && L.postRender(() => i(t, ni(t)));
}
function Ga({ root: e, ...t }) {
  let n = e || document;
  df.has(n) || df.set(n, {});
  let r = df.get(n),
    i = JSON.stringify(t);
  return (r[i] || (r[i] = new IntersectionObserver(pf, { root: e, ...t })), r[i]);
}
function Ka(e, t, n) {
  let r = Ga(t);
  return (
    uf.set(e, n),
    r.observe(e),
    () => {
      (uf.delete(e), r.unobserve(e));
    }
  );
}
function qa({ viewport: e = {} }, { viewport: t = {} } = {}) {
  return (n) => e[n] !== t[n];
}
function Ja(e, t, n) {
  p(() => e.on(t, n), [e, t, n]);
}
function Ya(e, t, n, r) {
  let i = n[t],
    { length: a, position: o } = Cf[t],
    s = i.current,
    c = n.time;
  ((i.current = e[`scroll${o}`]),
    (i.scrollLength = e[`scroll${a}`] - e[`client${a}`]),
    (i.offset.length = 0),
    (i.offset[0] = 0),
    (i.offset[1] = i.scrollLength),
    (i.progress = vs(0, i.scrollLength, i.current)));
  let l = r - c;
  i.velocity = l > bf ? 0 : Le(i.current - s, l);
}
function Xa(e, t, n) {
  (Ya(e, `x`, t, n), Ya(e, `y`, t, n), (t.time = n));
}
function Za(e, t) {
  let n = { x: 0, y: 0 },
    r = e;
  for (; r && r !== t; )
    if (rn(r)) ((n.x += r.offsetLeft), (n.y += r.offsetTop), (r = r.offsetParent));
    else if (r.tagName === `svg`) {
      let e = r.getBoundingClientRect();
      r = r.parentElement;
      let t = r.getBoundingClientRect();
      ((n.x += e.left - t.left), (n.y += e.top - t.top));
    } else if (r instanceof SVGGraphicsElement) {
      let { x: e, y: t } = r.getBBox();
      ((n.x += e), (n.y += t));
      let i = null,
        a = r.parentNode;
      for (; !i; ) (a.tagName === `svg` && (i = a), (a = r.parentNode));
      r = i;
    } else break;
  return n;
}
function Qa(e, t, n = 0) {
  let r = 0;
  if ((e in wf && (e = wf[e]), typeof e == `string`)) {
    let t = parseFloat(e);
    e.endsWith(`px`)
      ? (r = t)
      : e.endsWith(`%`)
        ? (e = t / 100)
        : e.endsWith(`vw`)
          ? (r = (t / 100) * document.documentElement.clientWidth)
          : e.endsWith(`vh`)
            ? (r = (t / 100) * document.documentElement.clientHeight)
            : (e = t);
  }
  return (typeof e == `number` && (r = t * e), n + r);
}
function $a(e, t, n, r) {
  let i = Array.isArray(e) ? e : Tf,
    a = 0,
    o = 0;
  return (
    typeof e == `number`
      ? (i = [e, e])
      : typeof e == `string` &&
        ((e = e.trim()), (i = e.includes(` `) ? e.split(` `) : [e, wf[e] ? e : `0`])),
    (a = Qa(i[0], n, r)),
    (o = Qa(i[1], t)),
    a - o
  );
}
function eo(e) {
  return `getBBox` in e && e.tagName !== `svg`
    ? e.getBBox()
    : { width: e.clientWidth, height: e.clientHeight };
}
function to(e, t, n) {
  let { offset: r = Ef.All } = n,
    { target: i = e, axis: a = `y` } = n,
    o = a === `y` ? `height` : `width`,
    s = i === e ? Df : Za(i, e),
    c = i === e ? { width: e.scrollWidth, height: e.scrollHeight } : eo(i),
    l = { width: e.clientWidth, height: e.clientHeight };
  t[a].offset.length = 0;
  let u = !t[a].interpolate,
    d = r.length;
  for (let e = 0; e < d; e++) {
    let n = $a(r[e], l[o], c[o], s[a]);
    (!u && n !== t[a].interpolatorOffsets[e] && (u = !0), (t[a].offset[e] = n));
  }
  (u &&
    ((t[a].interpolate = yt(t[a].offset, xt(r), { clamp: !1 })),
    (t[a].interpolatorOffsets = [...t[a].offset])),
    (t[a].progress = A(0, 1, t[a].interpolate(t[a].current))));
}
function no(e, t = e, n) {
  if (((n.x.targetOffset = 0), (n.y.targetOffset = 0), t !== e)) {
    let r = t;
    for (; r && r !== e; )
      ((n.x.targetOffset += r.offsetLeft), (n.y.targetOffset += r.offsetTop), (r = r.offsetParent));
  }
  ((n.x.targetLength = t === e ? t.scrollWidth : t.clientWidth),
    (n.y.targetLength = t === e ? t.scrollHeight : t.clientHeight),
    (n.x.containerLength = e.clientWidth),
    (n.y.containerLength = e.clientHeight));
}
function ro(e, t, n, r = {}) {
  return {
    measure: (t) => {
      (no(e, r.target, n), Xa(e, n, t), (r.offset || r.target) && to(e, n, r));
    },
    notify: () => t(n),
  };
}
function io(e, { container: t = document.scrollingElement, ...n } = {}) {
  if (!t) return N;
  let r = Af.get(t);
  r || ((r = new Set()), Af.set(t, r));
  let i = ro(t, e, Sf(), n);
  if ((r.add(i), !Of.has(t))) {
    let e = () => {
        for (let e of r) e.measure(z.timestamp);
        L.preUpdate(n);
      },
      n = () => {
        for (let e of r) e.notify();
      },
      i = () => L.read(e);
    Of.set(t, i);
    let a = jf(t);
    (o.addEventListener(`resize`, i, { passive: !0 }),
      t !== document.documentElement && kf.set(t, Sn(t, i)),
      a.addEventListener(`scroll`, i, { passive: !0 }),
      i());
  }
  let a = Of.get(t);
  return (
    L.read(a, !1, !0),
    () => {
      R(a);
      let e = Af.get(t);
      if (!e || (e.delete(i), e.size)) return;
      let n = Of.get(t);
      (Of.delete(t),
        n &&
          (jf(t).removeEventListener(`scroll`, n),
          kf.get(t)?.(),
          o.removeEventListener(`resize`, n)));
    }
  );
}
function ao(e) {
  let t = { value: 0 };
  return {
    currentTime: t,
    cancel: io((n) => {
      t.value = n[e.axis].progress * 100;
    }, e),
  };
}
function oo({ source: e, container: t, ...n }) {
  let { axis: r } = n;
  e && (t = e);
  let i = Mf.get(t) ?? new Map();
  Mf.set(t, i);
  let a = n.target ?? `self`,
    o = i.get(a) ?? {},
    s = r + (n.offset ?? []).join(`,`);
  return (
    o[s] ||
      (o[s] =
        !n.target && sl()
          ? new ScrollTimeline({ source: t, axis: r })
          : ao({ container: t, ...n })),
    o[s]
  );
}
function so(e, t) {
  let n = oo(t);
  return e.attachTimeline({
    timeline: t.target ? void 0 : n,
    observe: (e) => (
      e.pause(),
      Cn((t) => {
        e.time = e.iterationDuration * t;
      }, n)
    ),
  });
}
function co(e) {
  return e.length === 2;
}
function lo(e, t) {
  return co(e)
    ? io((n) => {
        e(n[t.axis].progress, n);
      }, t)
    : Cn(e, oo(t));
}
function uo(e, { axis: t = `y`, container: n = document.scrollingElement, ...r } = {}) {
  if (!n) return N;
  let i = { axis: t, container: n, ...r };
  return typeof e == `function` ? lo(e, i) : so(e, i);
}
function fo({ container: e, target: t, ...n } = {}) {
  let r = E(Nf),
    i = b(null),
    o = b(!1),
    c = a(
      () => (
        (i.current = uo(
          (e, { x: t, y: n }) => {
            (r.scrollX.set(t.current),
              r.scrollXProgress.set(t.progress),
              r.scrollY.set(n.current),
              r.scrollYProgress.set(n.progress));
          },
          { ...n, container: e?.current || void 0, target: t?.current || void 0 }
        )),
        () => {
          i.current?.();
        }
      ),
      [e, t, JSON.stringify(n.offset)]
    );
  return (
    ds(() => {
      if (((o.current = !1), Pf(e) || Pf(t))) {
        o.current = !0;
        return;
      } else return c();
    }, [c]),
    s(() => {
      if (o.current)
        return (
          j(!Pf(e), `Container ref is defined but not hydrated`, `use-scroll-ref`),
          j(!Pf(t), `Target ref is defined but not hydrated`, `use-scroll-ref`),
          c()
        );
    }, [c]),
    r
  );
}
function po(e) {
  let t = E(() => T(e)),
    { isStatic: n } = u(Z);
  if (n) {
    let [, n] = f(e);
    s(() => t.on(`change`, n), []);
  }
  return t;
}
function mo(e, t) {
  let n = po(t()),
    r = () => n.set(t());
  return (
    r(),
    ds(() => {
      let t = () => L.preRender(r, !1, !0),
        n = e.map((e) => e.on(`change`, t));
      return () => {
        (n.forEach((e) => e()), R(r));
      };
    }),
    n
  );
}
function ho(e) {
  ((Ul.current = []), e());
  let t = mo(Ul.current, e);
  return ((Ul.current = void 0), t);
}
function go(e, t, n, r) {
  if (typeof e == `function`) return ho(e);
  let i = typeof t == `function` ? t : Dn(t, n, r);
  return Array.isArray(e) ? _o(e, i) : _o([e], ([e]) => i(e));
}
function _o(e, t) {
  let n = E(() => []);
  return mo(e, () => {
    n.length = 0;
    let r = e.length;
    for (let t = 0; t < r; t++) n[t] = e[t].get();
    return t(n);
  });
}
function vo(e, t = {}) {
  let { isStatic: n } = u(Z),
    r = () => (X(e) ? e.get() : e);
  if (n) return go(r);
  let i = po(r());
  return (p(() => An(i, e, t), [i, JSON.stringify(t)]), i);
}
function yo(e) {
  let t = b(0),
    { isStatic: n } = u(Z);
  s(() => {
    if (n) return;
    let r = ({ timestamp: n, delta: r }) => {
      ((t.current ||= n), e(n - t.current, r));
    };
    return (L.update(r, !0), () => R(r));
  }, [e]);
}
function bo(e) {
  let t = po(e.getVelocity()),
    n = () => {
      let r = e.getVelocity();
      (t.set(r), r && L.update(n));
    };
  return (
    Ja(e, `change`, () => {
      L.update(n, !1, !0);
    }),
    t
  );
}
function xo() {
  !Ju.current && Mr();
  let [e] = f(qu.current);
  return e;
}
function So() {
  let e = xo(),
    { reducedMotion: t } = u(Z);
  return t === `never` ? !1 : t === `always` ? !0 : e;
}
function Co(e) {
  e.values.forEach((e) => e.stop());
}
function wo(e, t) {
  [...t].reverse().forEach((n) => {
    let r = e.getVariant(n);
    (r && Lr(e, r),
      e.variantChildren &&
        e.variantChildren.forEach((e) => {
          wo(e, t);
        }));
  });
}
function To(e, t) {
  if (Array.isArray(t)) return wo(e, t);
  if (typeof t == `string`) return wo(e, [t]);
  Lr(e, t);
}
function Eo() {
  let e = !1,
    t = new Set(),
    n = {
      subscribe(e) {
        return (t.add(e), () => void t.delete(e));
      },
      start(n, r) {
        j(
          e,
          `controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.`
        );
        let i = [];
        return (
          t.forEach((e) => {
            i.push(Jr(e, n, { transitionOverride: r }));
          }),
          Promise.all(i)
        );
      },
      set(n) {
        return (
          j(
            e,
            `controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.`
          ),
          t.forEach((e) => {
            To(e, n);
          })
        );
      },
      stop() {
        t.forEach((e) => {
          Co(e);
        });
      },
      mount() {
        return (
          (e = !0),
          () => {
            ((e = !1), n.stop());
          }
        );
      },
    };
  return n;
}
function Do(e) {
  return typeof e == `object` && !Array.isArray(e);
}
function Oo(e, t, n, r) {
  return typeof e == `string` && Do(t)
    ? nn(e, n, r)
    : e instanceof NodeList
      ? Array.from(e)
      : Array.isArray(e)
        ? e
        : [e];
}
function ko(e, t, n) {
  return e * (t + 1);
}
function Ao(e, t, n, r) {
  return typeof t == `number`
    ? t
    : t.startsWith(`-`) || t.startsWith(`+`)
      ? Math.max(0, e + parseFloat(t))
      : t === `<`
        ? n
        : t.startsWith(`<`)
          ? Math.max(0, n + parseFloat(t.slice(1)))
          : (r.get(t) ?? e);
}
function jo(e, t, n) {
  for (let r = 0; r < e.length; r++) {
    let i = e[r];
    i.at > t && i.at < n && (Ne(e, i), r--);
  }
}
function Mo(e, t, n, r, i, a) {
  jo(e, i, a);
  for (let o = 0; o < t.length; o++) e.push({ value: t[o], at: K(i, a, r[o]), easing: Be(n, o) });
}
function No(e, t) {
  for (let n = 0; n < e.length; n++) e[n] = e[n] / (t + 1);
}
function Po(e, t) {
  return e.at === t.at ? (e.value === null ? 1 : t.value === null ? -1 : 0) : e.at - t.at;
}
function Fo(e, { defaultTransition: t = {}, ...n } = {}, r, i) {
  let a = t.duration || 0.3,
    o = new Map(),
    s = new Map(),
    c = {},
    l = new Map(),
    u = 0,
    d = 0,
    f = 0;
  for (let n = 0; n < e.length; n++) {
    let o = e[n];
    if (typeof o == `string`) {
      l.set(o, d);
      continue;
    } else if (!Array.isArray(o)) {
      l.set(o.name, Ao(d, o.at, u, l));
      continue;
    }
    let [p, m, h = {}] = o;
    h.at !== void 0 && (d = Ao(d, h.at, u, l));
    let g = 0,
      _ = (e, n, r, o = 0, s = 0) => {
        let c = Ro(e),
          {
            delay: l = 0,
            times: u = xt(c),
            type: p = `keyframes`,
            repeat: m,
            repeatType: h,
            repeatDelay: _ = 0,
            ...v
          } = n,
          { ease: y = t.ease || `easeOut`, duration: b } = n,
          x = typeof l == `function` ? l(o, s) : l,
          S = c.length,
          ee = Bt(p) ? p : i?.[p || `keyframes`];
        if (S <= 2 && ee) {
          let e = 100;
          if (S === 2 && zf(c)) {
            let t = c[1] - c[0];
            e = Math.abs(t);
          }
          let t = { ...v };
          b !== void 0 && (t.duration = P(b));
          let n = lt(t, e, ee);
          ((y = n.ease), (b = n.duration));
        }
        b ??= a;
        let C = d + x;
        u.length === 1 && u[0] === 0 && (u[1] = 1);
        let te = u.length - c.length;
        if ((te > 0 && bt(u, te), c.length === 1 && c.unshift(null), m)) {
          (j(m < Lf, `Repeat count too high, must be less than 20`, `repeat-count-high`),
            (b = ko(b, m)));
          let e = [...c],
            t = [...u];
          y = Array.isArray(y) ? [...y] : [y];
          let n = [...y];
          for (let r = 0; r < m; r++) {
            c.push(...e);
            for (let i = 0; i < e.length; i++)
              (u.push(t[i] + (r + 1)), y.push(i === 0 ? `linear` : Be(n, i - 1)));
          }
          No(u, m);
        }
        let w = C + b;
        (Mo(r, c, y, u, C, w), (g = Math.max(x + b, g)), (f = Math.max(w, f)));
      };
    if (X(p)) {
      let e = Io(p, s);
      _(m, h, Lo(`default`, e));
    } else {
      let e = Oo(p, m, r, c),
        t = e.length;
      for (let n = 0; n < t; n++) {
        ((m = m), (h = h));
        let r = e[n],
          i = Io(r, s);
        for (let e in m) _(m[e], zo(h, e), Lo(e, i), n, t);
      }
    }
    ((u = d), (d += g));
  }
  return (
    s.forEach((e, r) => {
      for (let i in e) {
        let a = e[i];
        a.sort(Po);
        let s = [],
          c = [],
          l = [];
        for (let e = 0; e < a.length; e++) {
          let { at: t, value: n, easing: r } = a[e];
          (s.push(n), c.push(vs(0, f, t)), l.push(r || `easeOut`));
        }
        (c[0] !== 0 && (c.unshift(0), s.unshift(s[0]), l.unshift(If)),
          c[c.length - 1] !== 1 && (c.push(1), s.push(null)),
          o.has(r) || o.set(r, { keyframes: {}, transition: {} }));
        let u = o.get(r);
        ((u.keyframes[i] = s), (u.transition[i] = { ...t, duration: f, ease: l, times: c, ...n }));
      }
    }),
    o
  );
}
function Io(e, t) {
  return (!t.has(e) && t.set(e, {}), t.get(e));
}
function Lo(e, t) {
  return (t[e] || (t[e] = []), t[e]);
}
function Ro(e) {
  return Array.isArray(e) ? e : [e];
}
function zo(e, t) {
  return e && e[t] ? { ...e, ...e[t] } : { ...e };
}
function Bo(e, t) {
  return e in t;
}
function Vo(e) {
  let t = {
      presenceContext: null,
      props: {},
      visualState: {
        renderState: { transform: {}, transformOrigin: {}, style: {}, vars: {}, attrs: {} },
        latestValues: {},
      },
    },
    n = hn(e) && !wn(e) ? new Td(t) : new Cd(t);
  (n.mount(e), Ku.set(e, n));
}
function Ho(e) {
  let t = new Bf({
    presenceContext: null,
    props: {},
    visualState: { renderState: { output: {} }, latestValues: {} },
  });
  (t.mount(e), Ku.set(e, t));
}
function Uo(e, t) {
  return X(e) || typeof e == `number` || (typeof e == `string` && !Do(t));
}
function Wo(e, t, n, r) {
  let i = [];
  if (Uo(e, t)) i.push(ea(e, (Do(t) && t.default) || t, n && (n.default || n)));
  else {
    let a = Oo(e, t, r),
      o = a.length;
    j(!!o, `No valid elements provided.`, `no-valid-elements`);
    for (let e = 0; e < o; e++) {
      let r = a[e];
      j(
        r !== null,
        `You're trying to perform an animation on null. Ensure that selectors are correctly finding elements and refs are correctly hydrated.`,
        `animate-null`
      );
      let s = r instanceof Element ? Vo : Ho;
      Ku.has(r) || s(r);
      let c = Ku.get(r),
        l = { ...n };
      (`delay` in l && typeof l.delay == `function` && (l.delay = l.delay(e, o)),
        i.push(...Wr(c, { ...t, transition: l }, {})));
    }
  }
  return i;
}
function Go(e, t, n) {
  let r = [];
  return (
    Fo(e, t, n, { spring: gt }).forEach(({ keyframes: e, transition: t }, n) => {
      r.push(...Wo(n, e, t));
    }),
    r
  );
}
function Ko(e) {
  return Array.isArray(e) && e.some(Array.isArray);
}
function qo(e) {
  function t(t, n, r) {
    let i = [],
      a;
    if (Ko(t)) i = Go(t, n, e);
    else {
      let { onComplete: o, ...s } = r || {};
      (typeof o == `function` && (a = o), (i = Wo(t, n, s, e)));
    }
    let o = new Sl(i);
    return (
      a && o.finished.then(a),
      e &&
        (e.animations.push(o),
        o.finished.then(() => {
          Ne(e.animations, o);
        })),
      o
    );
  }
  return t;
}
function Jo() {
  let e = E(Eo);
  return (ds(e.mount, []), e);
}
function Yo(e) {
  return typeof e == `object` && !!e && Hu in e;
}
function Xo(e) {
  if (Yo(e)) return e[Hu];
}
function Zo() {
  return Qo;
}
function Qo(e) {
  rf.current && ((rf.current.isUpdating = !1), rf.current.blockUpdate(), e && e());
}
function $o() {
  return a(() => {
    let e = rf.current;
    e && e.resetTree();
  }, []);
}
function es(e, t, { root: n, margin: r, amount: i = `some` } = {}) {
  let a = nn(e),
    o = new WeakMap(),
    s = new IntersectionObserver(
      (e) => {
        e.forEach((e) => {
          let n = o.get(e.target);
          if (e.isIntersecting !== !!n)
            if (e.isIntersecting) {
              let n = t(e.target, e);
              typeof n == `function` ? o.set(e.target, n) : s.unobserve(e.target);
            } else typeof n == `function` && (n(e), o.delete(e.target));
        });
      },
      { root: n, rootMargin: r, threshold: typeof i == `number` ? i : Uf[i] }
    );
  return (a.forEach((e) => s.observe(e)), () => s.disconnect());
}
function ts(e, { root: t, margin: n, amount: r, once: i = !1, initial: a = !1 } = {}) {
  let [o, c] = f(a);
  return (
    s(() => {
      if (!e.current || (i && o)) return;
      let a = () => (c(!0), i ? void 0 : () => c(!1)),
        s = { root: (t && t.current) || void 0, margin: n, amount: r };
      return es(e.current, a, s);
    }, [t, e, n, i, r]),
    o
  );
}
function ns() {
  let [e, t] = Vn(),
    n = Zo(),
    r = b(-1);
  return (
    s(() => {
      L.postRender(() =>
        L.postRender(() => {
          t === r.current && (M.instantAnimations = !1);
        })
      );
    }, [t]),
    (i) => {
      n(() => {
        ((M.instantAnimations = !0), e(), i(), (r.current = t + 1));
      });
    }
  );
}
function rs(e, t, n, r) {
  if (!r) return e;
  let i = e.findIndex((e) => e.value === t);
  if (i === -1) return e;
  let a = r > 0 ? 1 : -1,
    o = e[i + a];
  if (!o) return e;
  let s = e[i],
    c = o.layout,
    l = K(c.min, c.max, 0.5);
  return (a === 1 && s.layout.max + n > l) || (a === -1 && s.layout.min + n < l)
    ? Pe(e, i, i + a)
    : e;
}
function is({ children: e, as: t = `ul`, axis: n = `y`, onReorder: r, values: i, ...a }, o) {
  let c = E(() => vf[t]),
    l = [],
    u = b(!1);
  j(!!i, `Reorder.Group must be provided a values prop`, `reorder-values`);
  let d = {
    axis: n,
    registerItem: (e, t) => {
      let r = l.findIndex((t) => e === t.value);
      (r === -1 ? l.push({ value: e, layout: t[n] }) : (l[r].layout = t[n]), l.sort(os));
    },
    updateOrder: (e, t, n) => {
      if (u.current) return;
      let a = rs(l, e, t, n);
      l !== a && ((u.current = !0), r(a.map(as).filter((e) => i.indexOf(e) !== -1)));
    },
  };
  return (
    s(() => {
      u.current = !1;
    }),
    _(c, { ...a, ref: o, ignoreStrict: !0, children: _(Kf.Provider, { value: d, children: e }) })
  );
}
function as(e) {
  return e.value;
}
function os(e, t) {
  return e.layout.min - t.layout.min;
}
function ss(e, t = 0) {
  return X(e) ? e : po(t);
}
function cs(
  { children: e, style: t = {}, value: n, as: r = `li`, onDrag: i, layout: a = !0, ...o },
  s
) {
  let c = E(() => vf[r]),
    l = u(Kf),
    d = { x: ss(t.x), y: ss(t.y) },
    f = go([d.x, d.y], ([e, t]) => (e || t ? 1 : `unset`));
  j(!!l, `Reorder.Item must be a child of Reorder.Group`, `reorder-item-child`);
  let { axis: p, registerItem: m, updateOrder: h } = l;
  return _(c, {
    drag: p,
    ...o,
    dragSnapToOrigin: !0,
    style: { ...t, x: d.x, y: d.y, zIndex: f },
    layout: a,
    onDrag: (e, t) => {
      let { velocity: r } = t;
      (r[p] && h(n, d[p].get(), r[p]), i && i(e, t));
    },
    onLayoutMeasure: (e) => m(n, e),
    ref: s,
    ignoreStrict: !0,
    children: e,
  });
}
var ls,
  us,
  ds,
  fs,
  A,
  ps,
  j,
  M,
  ms,
  hs,
  N,
  gs,
  _s,
  vs,
  ys,
  P,
  F,
  bs,
  xs,
  Ss,
  Cs,
  ws,
  Ts,
  Es,
  Ds,
  Os,
  ks,
  As,
  js,
  Ms,
  Ns,
  Ps,
  Fs,
  Is,
  Ls,
  Rs,
  zs,
  Bs,
  I,
  Vs,
  Hs,
  L,
  R,
  z,
  Us,
  Ws,
  B,
  Gs,
  Ks,
  qs,
  Js,
  Ys,
  Xs,
  Zs,
  Qs,
  $s,
  ec,
  tc,
  nc,
  rc,
  ic,
  ac,
  oc,
  sc,
  cc,
  lc,
  V,
  H,
  U,
  uc,
  dc,
  fc,
  pc,
  W,
  mc,
  hc,
  gc,
  _c,
  vc,
  yc,
  bc,
  xc,
  G,
  K,
  Sc,
  Cc,
  wc,
  Tc,
  Ec,
  Dc,
  Oc,
  kc,
  Ac,
  q,
  jc,
  Mc,
  Nc,
  Pc,
  Fc,
  Ic,
  Lc,
  Rc,
  zc,
  Bc,
  Vc,
  Hc,
  Uc,
  Wc,
  Gc,
  Kc,
  qc,
  Jc,
  Yc,
  Xc,
  Zc,
  Qc,
  $c,
  el,
  tl,
  J,
  nl,
  rl,
  il,
  al,
  ol,
  sl,
  cl,
  ll,
  ul,
  dl,
  fl,
  pl,
  ml,
  hl,
  gl,
  _l,
  vl,
  yl,
  bl,
  xl,
  Sl,
  Cl,
  wl,
  Tl,
  El,
  Dl,
  Ol,
  kl,
  Al,
  jl,
  Ml,
  Nl,
  Pl,
  Fl,
  Il,
  Ll,
  Rl,
  zl,
  Bl,
  Vl,
  Hl,
  Ul,
  Wl,
  Gl,
  Kl,
  Y,
  ql,
  Jl,
  Yl,
  Xl,
  Zl,
  Ql,
  $l,
  eu,
  tu,
  nu,
  ru,
  iu,
  X,
  au,
  ou,
  Z,
  su,
  cu,
  lu,
  uu,
  du,
  fu,
  pu,
  mu,
  hu,
  gu,
  _u,
  vu,
  yu,
  bu,
  xu,
  Su,
  Cu,
  wu,
  Tu,
  Eu,
  Du,
  Ou,
  ku,
  Au,
  ju,
  Mu,
  Nu,
  Pu,
  Fu,
  Iu,
  Lu,
  Ru,
  zu,
  Bu,
  Vu,
  Hu,
  Uu,
  Wu,
  Gu,
  Q,
  Ku,
  qu,
  Ju,
  Yu,
  Xu,
  Zu,
  Qu,
  $u,
  ed,
  td,
  nd,
  rd,
  id,
  ad,
  od,
  sd,
  $,
  cd,
  ld,
  ud,
  dd,
  fd,
  pd,
  md,
  hd,
  gd,
  _d,
  vd,
  yd,
  bd,
  xd,
  Sd,
  Cd,
  wd,
  Td,
  Ed,
  Dd,
  Od,
  kd,
  Ad,
  jd,
  Md,
  Nd,
  Pd,
  Fd,
  Id,
  Ld,
  Rd,
  zd,
  Bd,
  Vd,
  Hd,
  Ud,
  Wd,
  Gd,
  Kd,
  qd,
  Jd,
  Yd,
  Xd,
  Zd,
  Qd,
  $d,
  ef,
  tf,
  nf,
  rf,
  af,
  of,
  sf,
  cf,
  lf,
  uf,
  df,
  ff,
  pf,
  mf,
  hf,
  gf,
  _f,
  vf,
  yf,
  bf,
  xf,
  Sf,
  Cf,
  wf,
  Tf,
  Ef,
  Df,
  Of,
  kf,
  Af,
  jf,
  Mf,
  Nf,
  Pf,
  Ff,
  If,
  Lf,
  Rf,
  zf,
  Bf,
  Vf,
  Hf,
  Uf,
  Wf,
  Gf,
  Kf,
  qf,
  Jf,
  Yf = t(() => {
    for (let e in (n(),
    je(),
    i(),
    S(),
    (ls = w({})),
    (us = o !== void 0),
    (ds = us ? te : s),
    (fs = w(null)),
    (A = (e, t, n) => (n > t ? t : n < e ? e : n)),
    (ps = () => {}),
    (j = () => {}),
    (M = {}),
    (ms = (e) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e)),
    (hs = (e) => /^0[^.\s]+$/u.test(e)),
    (N = (e) => e),
    (gs = (e, t) => (n) => t(e(n))),
    (_s = (...e) => e.reduce(gs)),
    (vs = (e, t, n) => {
      let r = t - e;
      return r === 0 ? 1 : (n - e) / r;
    }),
    (ys = class {
      constructor() {
        this.subscriptions = [];
      }
      add(e) {
        return (Me(this.subscriptions, e), () => Ne(this.subscriptions, e));
      }
      notify(e, t, n) {
        let r = this.subscriptions.length;
        if (r)
          if (r === 1) this.subscriptions[0](e, t, n);
          else
            for (let i = 0; i < r; i++) {
              let r = this.subscriptions[i];
              r && r(e, t, n);
            }
      }
      getSize() {
        return this.subscriptions.length;
      }
      clear() {
        this.subscriptions.length = 0;
      }
    }),
    (P = (e) => e * 1e3),
    (F = (e) => e / 1e3),
    (bs = (e, t, n) => {
      let r = t - e;
      return ((((n - e) % r) + r) % r) + e;
    }),
    (xs = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e),
    (Ss = 1e-7),
    (Cs = 12),
    (ws = (e) => (t) => (t <= 0.5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2)),
    (Ts = (e) => (t) => 1 - e(1 - t)),
    (Es = ze(0.33, 1.53, 0.69, 0.99)),
    (Ds = Ts(Es)),
    (Os = ws(Ds)),
    (ks = (e) => ((e *= 2) < 1 ? 0.5 * Ds(e) : 0.5 * (2 - 2 ** (-10 * (e - 1))))),
    (As = (e) => 1 - Math.sin(Math.acos(e))),
    (js = Ts(As)),
    (Ms = ws(As)),
    (Ns = ze(0.42, 0, 1, 1)),
    (Ps = ze(0, 0, 0.58, 1)),
    (Fs = ze(0.42, 0, 0.58, 1)),
    (Is = (e) => Array.isArray(e) && typeof e[0] != `number`),
    (Ls = (e) => Array.isArray(e) && typeof e[0] == `number`),
    (Rs = {
      linear: N,
      easeIn: Ns,
      easeInOut: Fs,
      easeOut: Ps,
      circIn: As,
      circInOut: Ms,
      circOut: js,
      backIn: Ds,
      backInOut: Os,
      backOut: Es,
      anticipate: ks,
    }),
    (zs = (e) => typeof e == `string`),
    (Bs = (e) => {
      if (Ls(e)) {
        j(
          e.length === 4,
          `Cubic bezier arrays must contain four numerical values.`,
          `cubic-bezier-length`
        );
        let [t, n, r, i] = e;
        return ze(t, n, r, i);
      } else if (zs(e))
        return (j(Rs[e] !== void 0, `Invalid easing type '${e}'`, `invalid-easing-type`), Rs[e]);
      return e;
    }),
    (I = { value: null, addProjectionMetrics: null }),
    (Vs = [
      `setup`,
      `read`,
      `resolveKeyframes`,
      `preUpdate`,
      `update`,
      `preRender`,
      `render`,
      `postRender`,
    ]),
    (Hs = 40),
    ({
      schedule: L,
      cancel: R,
      state: z,
      steps: Us,
    } = He(typeof requestAnimationFrame < `u` ? requestAnimationFrame : N, !0)),
    (B = {
      now: () => (
        Ws === void 0 &&
          B.set(z.isProcessing || M.useManualTiming ? z.timestamp : performance.now()),
        Ws
      ),
      set: (e) => {
        ((Ws = e), queueMicrotask(Ue));
      },
    }),
    (Gs = { layout: 0, mainThread: 0, waapi: 0 }),
    (Ks = (e) => (t) => typeof t == `string` && t.startsWith(e)),
    (qs = Ks(`--`)),
    (Js = Ks(`var(--`)),
    (Ys = (e) => (Js(e) ? Xs.test(e.split(`/*`)[0].trim()) : !1)),
    (Xs = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu),
    (Zs = { test: (e) => typeof e == `number`, parse: parseFloat, transform: (e) => e }),
    (Qs = { ...Zs, transform: (e) => A(0, 1, e) }),
    ($s = { ...Zs, default: 1 }),
    (ec = (e) => Math.round(e * 1e5) / 1e5),
    (tc = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu),
    (nc =
      /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu),
    (rc = (e, t) => (n) =>
      !!(
        (typeof n == `string` && nc.test(n) && n.startsWith(e)) ||
        (t && !We(n) && Object.prototype.hasOwnProperty.call(n, t))
      )),
    (ic = (e, t, n) => (r) => {
      if (typeof r != `string`) return r;
      let [i, a, o, s] = r.match(tc);
      return {
        [e]: parseFloat(i),
        [t]: parseFloat(a),
        [n]: parseFloat(o),
        alpha: s === void 0 ? 1 : parseFloat(s),
      };
    }),
    (ac = (e) => A(0, 255, e)),
    (oc = { ...Zs, transform: (e) => Math.round(ac(e)) }),
    (sc = {
      test: rc(`rgb`, `red`),
      parse: ic(`red`, `green`, `blue`),
      transform: ({ red: e, green: t, blue: n, alpha: r = 1 }) =>
        `rgba(` +
        oc.transform(e) +
        `, ` +
        oc.transform(t) +
        `, ` +
        oc.transform(n) +
        `, ` +
        ec(Qs.transform(r)) +
        `)`,
    }),
    (cc = { test: rc(`#`), parse: Ge, transform: sc.transform }),
    (lc = (e) => ({
      test: (t) => typeof t == `string` && t.endsWith(e) && t.split(` `).length === 1,
      parse: parseFloat,
      transform: (t) => `${t}${e}`,
    })),
    (V = lc(`deg`)),
    (H = lc(`%`)),
    (U = lc(`px`)),
    (uc = lc(`vh`)),
    (dc = lc(`vw`)),
    (fc = (() => ({
      ...H,
      parse: (e) => H.parse(e) / 100,
      transform: (e) => H.transform(e * 100),
    }))()),
    (pc = {
      test: rc(`hsl`, `hue`),
      parse: ic(`hue`, `saturation`, `lightness`),
      transform: ({ hue: e, saturation: t, lightness: n, alpha: r = 1 }) =>
        `hsla(` +
        Math.round(e) +
        `, ` +
        H.transform(ec(t)) +
        `, ` +
        H.transform(ec(n)) +
        `, ` +
        ec(Qs.transform(r)) +
        `)`,
    }),
    (W = {
      test: (e) => sc.test(e) || cc.test(e) || pc.test(e),
      parse: (e) => (sc.test(e) ? sc.parse(e) : pc.test(e) ? pc.parse(e) : cc.parse(e)),
      transform: (e) =>
        typeof e == `string` ? e : e.hasOwnProperty(`red`) ? sc.transform(e) : pc.transform(e),
      getAnimatableNone: (e) => {
        let t = W.parse(e);
        return ((t.alpha = 0), W.transform(t));
      },
    }),
    (mc =
      /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu),
    (hc = `number`),
    (gc = `color`),
    (_c = `var`),
    (vc = `var(`),
    (yc = '${}'),
    (bc =
      /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu),
    (xc = (e) => (typeof e == `number` ? 0 : W.test(e) ? W.getAnimatableNone(e) : e)),
    (G = { test: Ke, parse: Je, createTransformer: Ye, getAnimatableNone: Xe }),
    (K = (e, t, n) => e + (t - e) * n),
    (Sc = (e, t, n) => {
      let r = e * e,
        i = n * (t * t - r) + r;
      return i < 0 ? 0 : Math.sqrt(i);
    }),
    (Cc = [cc, sc, pc]),
    (wc = (e) => Cc.find((t) => t.test(e))),
    (Tc = (e, t) => {
      let n = et(e),
        r = et(t);
      if (!n || !r) return $e(e, t);
      let i = { ...n };
      return (e) => (
        (i.red = Sc(n.red, r.red, e)),
        (i.green = Sc(n.green, r.green, e)),
        (i.blue = Sc(n.blue, r.blue, e)),
        (i.alpha = K(n.alpha, r.alpha, e)),
        sc.transform(i)
      );
    }),
    (Ec = new Set([`none`, `hidden`])),
    (Dc = (e, t) => {
      let n = G.createTransformer(t),
        r = qe(e),
        i = qe(t);
      return r.indexes.var.length === i.indexes.var.length &&
        r.indexes.color.length === i.indexes.color.length &&
        r.indexes.number.length >= i.indexes.number.length
        ? (Ec.has(e) && !i.values.length) || (Ec.has(t) && !r.values.length)
          ? tt(e, t)
          : _s(it(ot(r, i), i.values), n)
        : (ps(
            !0,
            `Complex values '${e}' and '${t}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`,
            `complex-values-different`
          ),
          $e(e, t));
    }),
    (Oc = (e, t, n = 10) => {
      let r = ``,
        i = Math.max(Math.round(t / n), 2);
      for (let t = 0; t < i; t++) r += Math.round(e(t / (i - 1)) * 1e4) / 1e4 + `, `;
      return `linear(${r.substring(0, r.length - 2)})`;
    }),
    (kc = 2e4),
    (Ac = 5),
    (q = {
      stiffness: 100,
      damping: 10,
      mass: 1,
      velocity: 0,
      duration: 800,
      bounce: 0.3,
      visualDuration: 0.3,
      restSpeed: { granular: 0.01, default: 2 },
      restDelta: { granular: 0.005, default: 0.5 },
      minDuration: 0.01,
      maxDuration: 10,
      minDamping: 0.05,
      maxDamping: 1,
    }),
    (jc = 0.001),
    (Mc = 12),
    (Nc = [`duration`, `bounce`]),
    (Pc = [`stiffness`, `damping`, `mass`]),
    (gt.applyToOptions = (e) => {
      let t = lt(e, 100, gt);
      return ((e.ease = t.ease), (e.duration = P(t.duration)), (e.type = `keyframes`), e);
    }),
    (Fc = (e) => {
      let t = ({ timestamp: t }) => e(t);
      return {
        start: (e = !0) => L.update(t, e),
        stop: () => R(t),
        now: () => (z.isProcessing ? z.timestamp : B.now()),
      };
    }),
    (Ic = (e) => e !== null),
    (Lc = { decay: _t, inertia: _t, tween: wt, keyframes: wt, spring: gt }),
    (Rc = class {
      constructor() {
        this.updateFinished();
      }
      get finished() {
        return this._finished;
      }
      updateFinished() {
        this._finished = new Promise((e) => {
          this.resolve = e;
        });
      }
      notifyFinished() {
        this.resolve();
      }
      then(e, t) {
        return this.finished.then(e, t);
      }
    }),
    (zc = (e) => e / 100),
    (Bc = class extends Rc {
      constructor(e) {
        (super(),
          (this.state = `idle`),
          (this.startTime = null),
          (this.isStopped = !1),
          (this.currentTime = 0),
          (this.holdTime = null),
          (this.playbackSpeed = 1),
          (this.stop = () => {
            let { motionValue: e } = this.options;
            (e && e.updatedAt !== B.now() && this.tick(B.now()),
              (this.isStopped = !0),
              this.state !== `idle` && (this.teardown(), this.options.onStop?.()));
          }),
          Gs.mainThread++,
          (this.options = e),
          this.initAnimation(),
          this.play(),
          e.autoplay === !1 && this.pause());
      }
      initAnimation() {
        let { options: e } = this;
        Et(e);
        let { type: t = wt, repeat: n = 0, repeatDelay: r = 0, repeatType: i, velocity: a = 0 } = e,
          { keyframes: o } = e,
          s = t || wt;
        s !== wt &&
          typeof o[0] != `number` &&
          ((this.mixKeyframes = _s(zc, st(o[0], o[1]))), (o = [0, 100]));
        let c = s({ ...e, keyframes: o });
        (i === `mirror` &&
          (this.mirroredGenerator = s({ ...e, keyframes: [...o].reverse(), velocity: -a })),
          c.calculatedDuration === null && (c.calculatedDuration = ct(c)));
        let { calculatedDuration: l } = c;
        ((this.calculatedDuration = l),
          (this.resolvedDuration = l + r),
          (this.totalDuration = this.resolvedDuration * (n + 1) - r),
          (this.generator = c));
      }
      updateTime(e) {
        let t = Math.round(e - this.startTime) * this.playbackSpeed;
        this.holdTime === null ? (this.currentTime = t) : (this.currentTime = this.holdTime);
      }
      tick(e, t = !1) {
        let {
          generator: n,
          totalDuration: r,
          mixKeyframes: i,
          mirroredGenerator: a,
          resolvedDuration: o,
          calculatedDuration: s,
        } = this;
        if (this.startTime === null) return n.next(0);
        let {
          delay: c = 0,
          keyframes: l,
          repeat: u,
          repeatType: d,
          repeatDelay: f,
          type: p,
          onUpdate: m,
          finalKeyframe: h,
        } = this.options;
        (this.speed > 0
          ? (this.startTime = Math.min(this.startTime, e))
          : this.speed < 0 && (this.startTime = Math.min(e - r / this.speed, this.startTime)),
          t ? (this.currentTime = e) : this.updateTime(e));
        let g = this.currentTime - c * (this.playbackSpeed >= 0 ? 1 : -1),
          _ = this.playbackSpeed >= 0 ? g < 0 : g > r;
        ((this.currentTime = Math.max(g, 0)),
          this.state === `finished` && this.holdTime === null && (this.currentTime = r));
        let v = this.currentTime,
          y = n;
        if (u) {
          let e = Math.min(this.currentTime, r) / o,
            t = Math.floor(e),
            n = e % 1;
          (!n && e >= 1 && (n = 1),
            n === 1 && t--,
            (t = Math.min(t, u + 1)),
            t % 2 &&
              (d === `reverse` ? ((n = 1 - n), f && (n -= f / o)) : d === `mirror` && (y = a)),
            (v = A(0, 1, n) * o));
        }
        let b = _ ? { done: !1, value: l[0] } : y.next(v);
        i && (b.value = i(b.value));
        let { done: x } = b;
        !_ &&
          s !== null &&
          (x = this.playbackSpeed >= 0 ? this.currentTime >= r : this.currentTime <= 0);
        let S =
          this.holdTime === null && (this.state === `finished` || (this.state === `running` && x));
        return (
          S && p !== _t && (b.value = Tt(l, this.options, h, this.speed)),
          m && m(b.value),
          S && this.finish(),
          b
        );
      }
      then(e, t) {
        return this.finished.then(e, t);
      }
      get duration() {
        return F(this.calculatedDuration);
      }
      get iterationDuration() {
        let { delay: e = 0 } = this.options || {};
        return this.duration + F(e);
      }
      get time() {
        return F(this.currentTime);
      }
      set time(e) {
        ((e = P(e)),
          (this.currentTime = e),
          this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0
            ? (this.holdTime = e)
            : this.driver && (this.startTime = this.driver.now() - e / this.playbackSpeed),
          this.driver?.start(!1));
      }
      get speed() {
        return this.playbackSpeed;
      }
      set speed(e) {
        this.updateTime(B.now());
        let t = this.playbackSpeed !== e;
        ((this.playbackSpeed = e), t && (this.time = F(this.currentTime)));
      }
      play() {
        if (this.isStopped) return;
        let { driver: e = Fc, startTime: t } = this.options;
        ((this.driver ||= e((e) => this.tick(e))), this.options.onPlay?.());
        let n = this.driver.now();
        (this.state === `finished`
          ? (this.updateFinished(), (this.startTime = n))
          : this.holdTime === null
            ? (this.startTime ||= t ?? n)
            : (this.startTime = n - this.holdTime),
          this.state === `finished` &&
            this.speed < 0 &&
            (this.startTime += this.calculatedDuration),
          (this.holdTime = null),
          (this.state = `running`),
          this.driver.start());
      }
      pause() {
        ((this.state = `paused`), this.updateTime(B.now()), (this.holdTime = this.currentTime));
      }
      complete() {
        (this.state !== `running` && this.play(),
          (this.state = `finished`),
          (this.holdTime = null));
      }
      finish() {
        (this.notifyFinished(),
          this.teardown(),
          (this.state = `finished`),
          this.options.onComplete?.());
      }
      cancel() {
        ((this.holdTime = null),
          (this.startTime = 0),
          this.tick(0),
          this.teardown(),
          this.options.onCancel?.());
      }
      teardown() {
        ((this.state = `idle`),
          this.stopDriver(),
          (this.startTime = this.holdTime = null),
          Gs.mainThread--);
      }
      stopDriver() {
        this.driver &&= (this.driver.stop(), void 0);
      }
      sample(e) {
        return ((this.startTime = 0), this.tick(e, !0));
      }
      attachTimeline(e) {
        return (
          this.options.allowFlatten &&
            ((this.options.type = `keyframes`),
            (this.options.ease = `linear`),
            this.initAnimation()),
          this.driver?.stop(),
          e.observe(this)
        );
      }
    }),
    (Vc = (e) => (e * 180) / Math.PI),
    (Hc = (e) => Wc(Vc(Math.atan2(e[1], e[0])))),
    (Uc = {
      x: 4,
      y: 5,
      translateX: 4,
      translateY: 5,
      scaleX: 0,
      scaleY: 3,
      scale: (e) => (Math.abs(e[0]) + Math.abs(e[3])) / 2,
      rotate: Hc,
      rotateZ: Hc,
      skewX: (e) => Vc(Math.atan(e[1])),
      skewY: (e) => Vc(Math.atan(e[2])),
      skew: (e) => (Math.abs(e[1]) + Math.abs(e[2])) / 2,
    }),
    (Wc = (e) => ((e %= 360), e < 0 && (e += 360), e)),
    (Gc = Hc),
    (Kc = (e) => Math.sqrt(e[0] * e[0] + e[1] * e[1])),
    (qc = (e) => Math.sqrt(e[4] * e[4] + e[5] * e[5])),
    (Jc = {
      x: 12,
      y: 13,
      z: 14,
      translateX: 12,
      translateY: 13,
      translateZ: 14,
      scaleX: Kc,
      scaleY: qc,
      scale: (e) => (Kc(e) + qc(e)) / 2,
      rotateX: (e) => Wc(Vc(Math.atan2(e[6], e[5]))),
      rotateY: (e) => Wc(Vc(Math.atan2(-e[2], e[0]))),
      rotateZ: Gc,
      rotate: Gc,
      skewX: (e) => Vc(Math.atan(e[4])),
      skewY: (e) => Vc(Math.atan(e[1])),
      skew: (e) => (Math.abs(e[1]) + Math.abs(e[4])) / 2,
    }),
    (Yc = (e, t) => {
      let { transform: n = `none` } = getComputedStyle(e);
      return At(n, t);
    }),
    (Xc = [
      `transformPerspective`,
      `x`,
      `y`,
      `z`,
      `translateX`,
      `translateY`,
      `translateZ`,
      `scale`,
      `scaleX`,
      `scaleY`,
      `rotate`,
      `rotateX`,
      `rotateY`,
      `rotateZ`,
      `skew`,
      `skewX`,
      `skewY`,
    ]),
    (Zc = (() => new Set(Xc))()),
    (Qc = (e) => e === Zs || e === U),
    ($c = new Set([`x`, `y`, `z`])),
    (el = Xc.filter((e) => !$c.has(e))),
    (tl = {
      width: ({ x: e }, { paddingLeft: t = `0`, paddingRight: n = `0` }) =>
        e.max - e.min - parseFloat(t) - parseFloat(n),
      height: ({ y: e }, { paddingTop: t = `0`, paddingBottom: n = `0` }) =>
        e.max - e.min - parseFloat(t) - parseFloat(n),
      top: (e, { top: t }) => parseFloat(t),
      left: (e, { left: t }) => parseFloat(t),
      bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min),
      right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min),
      x: (e, { transform: t }) => At(t, `x`),
      y: (e, { transform: t }) => At(t, `y`),
    }),
    (tl.translateX = tl.x),
    (tl.translateY = tl.y),
    (J = new Set()),
    (nl = !1),
    (rl = !1),
    (il = !1),
    (al = class {
      constructor(e, t, n, r, i, a = !1) {
        ((this.state = `pending`),
          (this.isAsync = !1),
          (this.needsMeasurement = !1),
          (this.unresolvedKeyframes = [...e]),
          (this.onComplete = t),
          (this.name = n),
          (this.motionValue = r),
          (this.element = i),
          (this.isAsync = a));
      }
      scheduleResolve() {
        ((this.state = `scheduled`),
          this.isAsync
            ? (J.add(this), nl || ((nl = !0), L.read(Pt), L.resolveKeyframes(Nt)))
            : (this.readKeyframes(), this.complete()));
      }
      readKeyframes() {
        let { unresolvedKeyframes: e, name: t, element: n, motionValue: r } = this;
        if (e[0] === null) {
          let i = r?.get(),
            a = e[e.length - 1];
          if (i !== void 0) e[0] = i;
          else if (n && t) {
            let r = n.readValue(t, a);
            r != null && (e[0] = r);
          }
          (e[0] === void 0 && (e[0] = a), r && i === void 0 && r.set(e[0]));
        }
        Ot(e);
      }
      setFinalKeyframe() {}
      measureInitialState() {}
      renderEndStyles() {}
      measureEndState() {}
      complete(e = !1) {
        ((this.state = `complete`),
          this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, e),
          J.delete(this));
      }
      cancel() {
        this.state === `scheduled` && (J.delete(this), (this.state = `pending`));
      }
      resume() {
        this.state === `pending` && this.scheduleResolve();
      }
    }),
    (ol = (e) => e.startsWith(`--`)),
    (sl = Ie(() => o.ScrollTimeline !== void 0)),
    (cl = {}),
    (ll = Lt(() => {
      try {
        document.createElement(`div`).animate({ opacity: 0 }, { easing: `linear(0, 1)` });
      } catch {
        return !1;
      }
      return !0;
    }, `linearEasing`)),
    (ul = ([e, t, n, r]) => `cubic-bezier(${e}, ${t}, ${n}, ${r})`),
    (dl = {
      linear: `linear`,
      ease: `ease`,
      easeIn: `ease-in`,
      easeOut: `ease-out`,
      easeInOut: `ease-in-out`,
      circIn: ul([0, 0.65, 0.55, 1]),
      circOut: ul([0.55, 0, 1, 0.45]),
      backIn: ul([0.31, 0.01, 0.66, -0.59]),
      backOut: ul([0.33, 1.53, 0.69, 0.99]),
    }),
    (fl = class extends Rc {
      constructor(e) {
        if ((super(), (this.finishedTime = null), (this.isStopped = !1), !e)) return;
        let {
          element: t,
          name: n,
          keyframes: r,
          pseudoElement: i,
          allowFlatten: a = !1,
          finalKeyframe: o,
          onComplete: s,
        } = e;
        ((this.isPseudoElement = !!i),
          (this.allowFlatten = a),
          (this.options = e),
          j(
            typeof e.type != `string`,
            `Mini animate() doesn't support "type" as a string.`,
            `mini-spring`
          ));
        let c = Vt(e);
        ((this.animation = zt(t, n, r, c, i)),
          c.autoplay === !1 && this.animation.pause(),
          (this.animation.onfinish = () => {
            if (((this.finishedTime = this.time), !i)) {
              let e = Tt(r, this.options, o, this.speed);
              (this.updateMotionValue ? this.updateMotionValue(e) : It(t, n, e),
                this.animation.cancel());
            }
            (s?.(), this.notifyFinished());
          }));
      }
      play() {
        this.isStopped ||
          (this.animation.play(), this.state === `finished` && this.updateFinished());
      }
      pause() {
        this.animation.pause();
      }
      complete() {
        this.animation.finish?.();
      }
      cancel() {
        try {
          this.animation.cancel();
        } catch {}
      }
      stop() {
        if (this.isStopped) return;
        this.isStopped = !0;
        let { state: e } = this;
        e === `idle` ||
          e === `finished` ||
          (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(),
          this.isPseudoElement || this.cancel());
      }
      commitStyles() {
        this.isPseudoElement || this.animation.commitStyles?.();
      }
      get duration() {
        let e = this.animation.effect?.getComputedTiming?.().duration || 0;
        return F(Number(e));
      }
      get iterationDuration() {
        let { delay: e = 0 } = this.options || {};
        return this.duration + F(e);
      }
      get time() {
        return F(Number(this.animation.currentTime) || 0);
      }
      set time(e) {
        ((this.finishedTime = null), (this.animation.currentTime = P(e)));
      }
      get speed() {
        return this.animation.playbackRate;
      }
      set speed(e) {
        (e < 0 && (this.finishedTime = null), (this.animation.playbackRate = e));
      }
      get state() {
        return this.finishedTime === null ? this.animation.playState : `finished`;
      }
      get startTime() {
        return Number(this.animation.startTime);
      }
      set startTime(e) {
        this.animation.startTime = e;
      }
      attachTimeline({ timeline: e, observe: t }) {
        return (
          this.allowFlatten && this.animation.effect?.updateTiming({ easing: `linear` }),
          (this.animation.onfinish = null),
          e && sl() ? ((this.animation.timeline = e), N) : t(this)
        );
      }
    }),
    (pl = { anticipate: ks, backInOut: Os, circInOut: Ms }),
    (ml = 10),
    (hl = class extends fl {
      constructor(e) {
        (Ut(e), Et(e), super(e), e.startTime && (this.startTime = e.startTime), (this.options = e));
      }
      updateMotionValue(e) {
        let { motionValue: t, onUpdate: n, onComplete: r, element: i, ...a } = this.options;
        if (!t) return;
        if (e !== void 0) {
          t.set(e);
          return;
        }
        let o = new Bc({ ...a, autoplay: !1 }),
          s = P(this.finishedTime ?? this.time);
        (t.setWithVelocity(o.sample(s - ml).value, o.sample(s).value, ml), o.stop());
      }
    }),
    (gl = new Set([`opacity`, `clipPath`, `filter`, `transform`])),
    (_l = Ie(() => Object.hasOwnProperty.call(Element.prototype, `animate`))),
    (vl = (e, t) =>
      t === `zIndex`
        ? !1
        : !!(
            typeof e == `number` ||
            Array.isArray(e) ||
            (typeof e == `string` && (G.test(e) || e === `0`) && !e.startsWith(`url(`))
          )),
    (yl = 40),
    (bl = class extends Rc {
      constructor({
        autoplay: e = !0,
        delay: t = 0,
        type: n = `keyframes`,
        repeat: r = 0,
        repeatDelay: i = 0,
        repeatType: a = `loop`,
        keyframes: o,
        name: s,
        motionValue: c,
        element: l,
        ...u
      }) {
        (super(),
          (this.stop = () => {
            (this._animation && (this._animation.stop(), this.stopTimeline?.()),
              this.keyframeResolver?.cancel());
          }),
          (this.createdAt = B.now()));
        let d = {
          autoplay: e,
          delay: t,
          type: n,
          repeat: r,
          repeatDelay: i,
          repeatType: a,
          name: s,
          motionValue: c,
          element: l,
          ...u,
        };
        ((this.keyframeResolver = new (l?.KeyframeResolver || al)(
          o,
          (e, t, n) => this.onKeyframesResolved(e, t, d, !n),
          s,
          c,
          l
        )),
          this.keyframeResolver?.scheduleResolve());
      }
      onKeyframesResolved(e, t, n, r) {
        this.keyframeResolver = void 0;
        let { name: i, type: a, velocity: o, delay: s, isHandoff: c, onUpdate: l } = n;
        ((this.resolvedAt = B.now()),
          qt(e, i, a, o) ||
            ((M.instantAnimations || !s) && l?.(Tt(e, n, t)),
            (e[0] = e[e.length - 1]),
            Wt(n),
            (n.repeat = 0)));
        let u = {
            startTime: r
              ? this.resolvedAt && this.resolvedAt - this.createdAt > yl
                ? this.resolvedAt
                : this.createdAt
              : void 0,
            finalKeyframe: t,
            ...n,
            keyframes: e,
          },
          d = !c && Gt(u) ? new hl({ ...u, element: u.motionValue.owner.current }) : new Bc(u);
        (d.finished.then(() => this.notifyFinished()).catch(N),
          (this.pendingTimeline &&=
            ((this.stopTimeline = d.attachTimeline(this.pendingTimeline)), void 0)),
          (this._animation = d));
      }
      get finished() {
        return this._animation ? this.animation.finished : this._finished;
      }
      then(e, t) {
        return this.finished.finally(e).then(() => {});
      }
      get animation() {
        return (this._animation || (this.keyframeResolver?.resume(), Ft()), this._animation);
      }
      get duration() {
        return this.animation.duration;
      }
      get iterationDuration() {
        return this.animation.iterationDuration;
      }
      get time() {
        return this.animation.time;
      }
      set time(e) {
        this.animation.time = e;
      }
      get speed() {
        return this.animation.speed;
      }
      get state() {
        return this.animation.state;
      }
      set speed(e) {
        this.animation.speed = e;
      }
      get startTime() {
        return this.animation.startTime;
      }
      attachTimeline(e) {
        return (
          this._animation
            ? (this.stopTimeline = this.animation.attachTimeline(e))
            : (this.pendingTimeline = e),
          () => this.stop()
        );
      }
      play() {
        this.animation.play();
      }
      pause() {
        this.animation.pause();
      }
      complete() {
        this.animation.complete();
      }
      cancel() {
        (this._animation && this.animation.cancel(), this.keyframeResolver?.cancel());
      }
    }),
    (xl = class {
      constructor(e) {
        ((this.stop = () => this.runAll(`stop`)), (this.animations = e.filter(Boolean)));
      }
      get finished() {
        return Promise.all(this.animations.map((e) => e.finished));
      }
      getAll(e) {
        return this.animations[0][e];
      }
      setAll(e, t) {
        for (let n = 0; n < this.animations.length; n++) this.animations[n][e] = t;
      }
      attachTimeline(e) {
        let t = this.animations.map((t) => t.attachTimeline(e));
        return () => {
          t.forEach((e, t) => {
            (e && e(), this.animations[t].stop());
          });
        };
      }
      get time() {
        return this.getAll(`time`);
      }
      set time(e) {
        this.setAll(`time`, e);
      }
      get speed() {
        return this.getAll(`speed`);
      }
      set speed(e) {
        this.setAll(`speed`, e);
      }
      get state() {
        return this.getAll(`state`);
      }
      get startTime() {
        return this.getAll(`startTime`);
      }
      get duration() {
        return Jt(this.animations, `duration`);
      }
      get iterationDuration() {
        return Jt(this.animations, `iterationDuration`);
      }
      runAll(e) {
        this.animations.forEach((t) => t[e]());
      }
      play() {
        this.runAll(`play`);
      }
      pause() {
        this.runAll(`pause`);
      }
      cancel() {
        this.runAll(`cancel`);
      }
      complete() {
        this.runAll(`complete`);
      }
    }),
    (Sl = class extends xl {
      then(e, t) {
        return this.finished.finally(e).then(() => {});
      }
    }),
    (Cl = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u),
    (wl = 4),
    (Tl = new Set([`width`, `height`, `top`, `left`, `right`, `bottom`, ...Xc])),
    (El = (e) => (t) => t.test(e)),
    (Dl = [Zs, U, H, V, dc, uc, { test: (e) => e === `auto`, parse: (e) => e }]),
    (Ol = (e) => Dl.find(El(e))),
    (kl = {
      rotate: V,
      rotateX: V,
      rotateY: V,
      rotateZ: V,
      scale: $s,
      scaleX: $s,
      scaleY: $s,
      scaleZ: $s,
      skew: V,
      skewX: V,
      skewY: V,
      distance: U,
      translateX: U,
      translateY: U,
      translateZ: U,
      x: U,
      y: U,
      z: U,
      perspective: U,
      transformPerspective: U,
      opacity: Qs,
      originX: fc,
      originY: fc,
      originZ: U,
    }),
    (Al = { ...Zs, transform: Math.round }),
    (jl = {
      borderWidth: U,
      borderTopWidth: U,
      borderRightWidth: U,
      borderBottomWidth: U,
      borderLeftWidth: U,
      borderRadius: U,
      radius: U,
      borderTopLeftRadius: U,
      borderTopRightRadius: U,
      borderBottomRightRadius: U,
      borderBottomLeftRadius: U,
      width: U,
      maxWidth: U,
      height: U,
      maxHeight: U,
      top: U,
      right: U,
      bottom: U,
      left: U,
      padding: U,
      paddingTop: U,
      paddingRight: U,
      paddingBottom: U,
      paddingLeft: U,
      margin: U,
      marginTop: U,
      marginRight: U,
      marginBottom: U,
      marginLeft: U,
      backgroundPositionX: U,
      backgroundPositionY: U,
      ...kl,
      zIndex: Al,
      fillOpacity: Qs,
      strokeOpacity: Qs,
      numOctaves: Al,
    }),
    (Ml = new Set([`brightness`, `contrast`, `saturate`, `opacity`])),
    (Nl = /\b([a-z-]*)\(.*?\)/gu),
    (Pl = {
      ...G,
      getAnimatableNone: (e) => {
        let t = e.match(Nl);
        return t ? t.map(Qt).join(` `) : e;
      },
    }),
    (Fl = {
      ...jl,
      color: W,
      backgroundColor: W,
      outlineColor: W,
      fill: W,
      stroke: W,
      borderColor: W,
      borderTopColor: W,
      borderRightColor: W,
      borderBottomColor: W,
      borderLeftColor: W,
      filter: Pl,
      WebkitFilter: Pl,
    }),
    (Il = (e) => Fl[e]),
    (Ll = new Set([`auto`, `none`, `0`])),
    (Rl = class extends al {
      constructor(e, t, n, r, i) {
        super(e, t, n, r, i, !0);
      }
      readKeyframes() {
        let { unresolvedKeyframes: e, element: t, name: n } = this;
        if (!t || !t.current) return;
        super.readKeyframes();
        for (let n = 0; n < e.length; n++) {
          let r = e[n];
          if (typeof r == `string` && ((r = r.trim()), Ys(r))) {
            let i = Xt(r, t.current);
            (i !== void 0 && (e[n] = i), n === e.length - 1 && (this.finalKeyframe = r));
          }
        }
        if ((this.resolveNoneKeyframes(), !Tl.has(n) || e.length !== 2)) return;
        let [r, i] = e,
          a = Ol(r),
          o = Ol(i);
        if (a !== o)
          if (Qc(a) && Qc(o))
            for (let t = 0; t < e.length; t++) {
              let n = e[t];
              typeof n == `string` && (e[t] = parseFloat(n));
            }
          else tl[n] && (this.needsMeasurement = !0);
      }
      resolveNoneKeyframes() {
        let { unresolvedKeyframes: e, name: t } = this,
          n = [];
        for (let t = 0; t < e.length; t++) (e[t] === null || en(e[t])) && n.push(t);
        n.length && tn(e, n, t);
      }
      measureInitialState() {
        let { element: e, unresolvedKeyframes: t, name: n } = this;
        if (!e || !e.current) return;
        (n === `height` && (this.suspendedScrollY = o.pageYOffset),
          (this.measuredOrigin = tl[n](e.measureViewportBox(), o.getComputedStyle(e.current))),
          (t[0] = this.measuredOrigin));
        let r = t[t.length - 1];
        r !== void 0 && e.getValue(n, r).jump(r, !1);
      }
      measureEndState() {
        let { element: e, name: t, unresolvedKeyframes: n } = this;
        if (!e || !e.current) return;
        let r = e.getValue(t);
        r && r.jump(this.measuredOrigin, !1);
        let i = n.length - 1,
          a = n[i];
        ((n[i] = tl[t](e.measureViewportBox(), o.getComputedStyle(e.current))),
          a !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = a),
          this.removedTransforms?.length &&
            this.removedTransforms.forEach(([t, n]) => {
              e.getValue(t).set(n);
            }),
          this.resolveNoneKeyframes());
      }
    }),
    (zl = new Set([`opacity`, `clipPath`, `filter`, `transform`])),
    (Bl = (e, t) => (t && typeof e == `number` ? t.transform(e) : e)),
    (Vl = 30),
    (Hl = (e) => !isNaN(parseFloat(e))),
    (Ul = { current: void 0 }),
    (Wl = class {
      constructor(e, t = {}) {
        ((this.canTrackVelocity = null),
          (this.events = {}),
          (this.updateAndNotify = (e) => {
            let t = B.now();
            if (
              (this.updatedAt !== t && this.setPrevFrameValue(),
              (this.prev = this.current),
              this.setCurrent(e),
              this.current !== this.prev &&
                (this.events.change?.notify(this.current), this.dependents))
            )
              for (let e of this.dependents) e.dirty();
          }),
          (this.hasAnimated = !1),
          this.setCurrent(e),
          (this.owner = t.owner));
      }
      setCurrent(e) {
        ((this.current = e),
          (this.updatedAt = B.now()),
          this.canTrackVelocity === null &&
            e !== void 0 &&
            (this.canTrackVelocity = Hl(this.current)));
      }
      setPrevFrameValue(e = this.current) {
        ((this.prevFrameValue = e), (this.prevUpdatedAt = this.updatedAt));
      }
      onChange(e) {
        return this.on(`change`, e);
      }
      on(e, t) {
        this.events[e] || (this.events[e] = new ys());
        let n = this.events[e].add(t);
        return e === `change`
          ? () => {
              (n(),
                L.read(() => {
                  this.events.change.getSize() || this.stop();
                }));
            }
          : n;
      }
      clearListeners() {
        for (let e in this.events) this.events[e].clear();
      }
      attach(e, t) {
        ((this.passiveEffect = e), (this.stopPassiveEffect = t));
      }
      set(e) {
        this.passiveEffect ? this.passiveEffect(e, this.updateAndNotify) : this.updateAndNotify(e);
      }
      setWithVelocity(e, t, n) {
        (this.set(t),
          (this.prev = void 0),
          (this.prevFrameValue = e),
          (this.prevUpdatedAt = this.updatedAt - n));
      }
      jump(e, t = !0) {
        (this.updateAndNotify(e),
          (this.prev = e),
          (this.prevUpdatedAt = this.prevFrameValue = void 0),
          t && this.stop(),
          this.stopPassiveEffect && this.stopPassiveEffect());
      }
      dirty() {
        this.events.change?.notify(this.current);
      }
      addDependent(e) {
        ((this.dependents ||= new Set()), this.dependents.add(e));
      }
      removeDependent(e) {
        this.dependents && this.dependents.delete(e);
      }
      get() {
        return (Ul.current && Ul.current.push(this), this.current);
      }
      getPrevious() {
        return this.prev;
      }
      getVelocity() {
        let e = B.now();
        if (!this.canTrackVelocity || this.prevFrameValue === void 0 || e - this.updatedAt > Vl)
          return 0;
        let t = Math.min(this.updatedAt - this.prevUpdatedAt, Vl);
        return Le(parseFloat(this.current) - parseFloat(this.prevFrameValue), t);
      }
      start(e) {
        return (
          this.stop(),
          new Promise((t) => {
            ((this.hasAnimated = !0),
              (this.animation = e(t)),
              this.events.animationStart && this.events.animationStart.notify());
          }).then(() => {
            (this.events.animationComplete && this.events.animationComplete.notify(),
              this.clearAnimation());
          })
        );
      }
      stop() {
        (this.animation &&
          (this.animation.stop(),
          this.events.animationCancel && this.events.animationCancel.notify()),
          this.clearAnimation());
      }
      isAnimating() {
        return !!this.animation;
      }
      clearAnimation() {
        delete this.animation;
      }
      destroy() {
        (this.dependents?.clear(),
          this.events.destroy?.notify(),
          this.clearListeners(),
          this.stop(),
          this.stopPassiveEffect && this.stopPassiveEffect());
      }
    }),
    U.transform,
    ({ schedule: Gl, cancel: Kl } = He(queueMicrotask, !1)),
    (Y = { x: !1, y: !1 }),
    (ql = (e, t) => (t ? (e === t ? !0 : ql(e, t.parentElement)) : !1)),
    (Jl = (e) =>
      e.pointerType === `mouse`
        ? typeof e.button != `number` || e.button <= 0
        : e.isPrimary !== !1),
    (Yl = new Set([`BUTTON`, `INPUT`, `SELECT`, `TEXTAREA`, `A`])),
    (Xl = new WeakSet()),
    (Zl = (e, t) => {
      let n = e.currentTarget;
      if (!n) return;
      let r = dn(() => {
        if (Xl.has(n)) return;
        fn(n, `down`);
        let e = dn(() => {
          fn(n, `up`);
        });
        (n.addEventListener(`keyup`, e, t), n.addEventListener(`blur`, () => fn(n, `cancel`), t));
      });
      (n.addEventListener(`keydown`, r, t),
        n.addEventListener(`blur`, () => n.removeEventListener(`keydown`, r), t));
    }),
    (Ql = new WeakMap()),
    (eu = (e, t, n) => (r, i) =>
      i && i[0] ? i[0][e + `Size`] : hn(r) && `getBBox` in r ? r.getBBox()[t] : r[n]),
    (tu = eu(`inline`, `width`, `offsetWidth`)),
    (nu = eu(`block`, `height`, `offsetHeight`)),
    (ru = new Set()),
    (X = (e) => !!(e && e.getVelocity)),
    (au = [...Dl, W, G]),
    (ou = (e) => au.find(El(e))),
    Vs.reduce((e, t) => ((e[t] = (e) => R(e)), e), {}),
    (Z = w({ transformPagePoint: (e) => e, isStatic: !1, reducedMotion: `never` })),
    (su = class extends v {
      getSnapshotBeforeUpdate(e) {
        let t = this.props.childRef.current;
        if (t && e.isPresent && !this.props.isPresent) {
          let e = t.offsetParent,
            n = (rn(e) && e.offsetWidth) || 0,
            r = this.props.sizeRef.current;
          ((r.height = t.offsetHeight || 0),
            (r.width = t.offsetWidth || 0),
            (r.top = t.offsetTop),
            (r.left = t.offsetLeft),
            (r.right = n - r.width - r.left));
        }
        return null;
      }
      componentDidUpdate() {}
      render() {
        return this.props.children;
      }
    }),
    (cu = ({
      children: e,
      initial: t,
      isPresent: n,
      onExitComplete: r,
      custom: i,
      presenceAffectsLayout: a,
      mode: o,
      anchorX: c,
      root: l,
    }) => {
      let u = E(Ln),
        f = g(),
        p = !0,
        m = d(
          () => (
            (p = !1),
            {
              id: f,
              initial: t,
              isPresent: n,
              custom: i,
              onExitComplete: (e) => {
                u.set(e, !0);
                for (let e of u.values()) if (!e) return;
                r && r();
              },
              register: (e) => (u.set(e, !1), () => u.delete(e)),
            }
          ),
          [n, u, r]
        );
      return (
        a && p && (m = { ...m }),
        d(() => {
          u.forEach((e, t) => u.set(t, !1));
        }, [n]),
        s(() => {
          !n && !u.size && r && r();
        }, [n]),
        o === `popLayout` && (e = _(In, { isPresent: n, anchorX: c, root: l, children: e })),
        _(fs.Provider, { value: m, children: e })
      );
    }),
    (lu = (e) => e.key || ``),
    (uu = ({
      children: e,
      custom: t,
      initial: n = !0,
      onExitComplete: r,
      presenceAffectsLayout: i = !0,
      mode: a = `sync`,
      propagate: o = !1,
      anchorX: s = `left`,
      root: c,
    }) => {
      let [l, p] = Rn(o),
        m = d(() => zn(e), [e]),
        h = o && !l ? [] : m.map(lu),
        g = b(!0),
        v = b(m),
        y = E(() => new Map()),
        [x, S] = f(m),
        [C, te] = f(m);
      ds(() => {
        ((g.current = !1), (v.current = m));
        for (let e = 0; e < C.length; e++) {
          let t = lu(C[e]);
          h.includes(t) ? y.delete(t) : y.get(t) !== !0 && y.set(t, !1);
        }
      }, [C, h.length, h.join(`-`)]);
      let w = [];
      if (m !== x) {
        let e = [...m];
        for (let t = 0; t < C.length; t++) {
          let n = C[t],
            r = lu(n);
          h.includes(r) || (e.splice(t, 0, n), w.push(n));
        }
        return (a === `wait` && w.length && (e = w), te(zn(e)), S(m), null);
      }
      let { forceRender: ne } = u(ls);
      return _(ee, {
        children: C.map((e) => {
          let u = lu(e),
            d = o && !l ? !1 : m === C || h.includes(u);
          return _(
            cu,
            {
              isPresent: d,
              initial: !g.current || n ? void 0 : !1,
              custom: t,
              presenceAffectsLayout: i,
              mode: a,
              root: c,
              onExitComplete: d
                ? void 0
                : () => {
                    if (y.has(u)) y.set(u, !0);
                    else return;
                    let e = !0;
                    (y.forEach((t) => {
                      t || (e = !1);
                    }),
                      e && (ne?.(), te(v.current), o && p?.(), r && r()));
                  },
              anchorX: s,
              children: e,
            },
            u
          );
        }),
      });
    }),
    (du = w(null)),
    (fu = (e) => !e.isLayoutDirty && e.willUpdate(!1)),
    (pu = (e) => e === !0),
    (mu = (e) => pu(e === !0) || e === `id`),
    (hu = ({ children: e, id: t, inherit: n = !0 }) => {
      let r = u(ls),
        i = u(du),
        [a, o] = Vn(),
        s = b(null),
        c = r.id || i;
      s.current === null &&
        (mu(n) && c && (t = t ? c + `-` + t : c),
        (s.current = { id: t, group: (pu(n) && r.group) || Hn() }));
      let l = d(() => ({ ...s.current, forceRender: a }), [o]);
      return _(ls.Provider, { value: l, children: e });
    }),
    (gu = w({ strict: !1 })),
    (_u = {
      animation: [
        `animate`,
        `variants`,
        `whileHover`,
        `whileTap`,
        `exit`,
        `whileInView`,
        `whileFocus`,
        `whileDrag`,
      ],
      exit: [`exit`],
      drag: [`drag`, `dragControls`],
      focus: [`whileFocus`],
      hover: [`whileHover`, `onHoverStart`, `onHoverEnd`],
      tap: [`whileTap`, `onTap`, `onTapStart`, `onTapCancel`],
      pan: [`onPan`, `onPanStart`, `onPanSessionStart`, `onPanEnd`],
      inView: [`whileInView`, `onViewportEnter`, `onViewportLeave`],
      layout: [`layout`, `layoutId`],
    }),
    (vu = {}),
    _u))
      vu[e] = { isEnabled: (t) => _u[e].some((e) => !!t[e]) };
    ((yu = new Set(
      `animate.exit.variants.initial.style.values.variants.transition.transformTemplate.custom.inherit.onBeforeLayoutMeasure.onAnimationStart.onAnimationComplete.onUpdate.onDragStart.onDrag.onDragEnd.onMeasureDragConstraints.onDirectionLock.onDragTransitionEnd._dragX._dragY.onHoverStart.onHoverEnd.onViewportEnter.onViewportLeave.globalTapTarget.ignoreStrict.viewport`.split(
        `.`
      )
    )),
      (bu = (e) => !Wn(e)));
    try {
      Gn(fe(`@emotion/is-prop-valid`).default);
    } catch {}
    ((xu = w({})),
      (Su = {
        correct: (e, t) => {
          if (!t.target) return e;
          if (typeof e == `string`)
            if (U.test(e)) e = parseFloat(e);
            else return e;
          return `${Jn(e, t.target.x)}% ${Jn(e, t.target.y)}%`;
        },
      }),
      (Cu = {
        correct: (e, { treeScale: t, projectionDelta: n }) => {
          let r = e,
            i = G.parse(e);
          if (i.length > 5) return r;
          let a = G.createTransformer(e),
            o = typeof i[0] == `number` ? 0 : 1,
            s = n.x.scale * t.x,
            c = n.y.scale * t.y;
          ((i[0 + o] /= s), (i[1 + o] /= c));
          let l = K(s, c, 0.5);
          return (
            typeof i[2 + o] == `number` && (i[2 + o] /= l),
            typeof i[3 + o] == `number` && (i[3 + o] /= l),
            a(i)
          );
        },
      }),
      (wu = {
        borderRadius: {
          ...Su,
          applyTo: [
            `borderTopLeftRadius`,
            `borderTopRightRadius`,
            `borderBottomLeftRadius`,
            `borderBottomRightRadius`,
          ],
        },
        borderTopLeftRadius: Su,
        borderTopRightRadius: Su,
        borderBottomLeftRadius: Su,
        borderBottomRightRadius: Su,
        boxShadow: Cu,
      }),
      (Tu = {
        x: `translateX`,
        y: `translateY`,
        z: `translateZ`,
        transformPerspective: `perspective`,
      }),
      (Eu = Xc.length),
      (Du = [
        `animate`,
        `whileInView`,
        `whileFocus`,
        `whileHover`,
        `whileTap`,
        `whileDrag`,
        `exit`,
      ]),
      (Ou = [`initial`, ...Du]),
      (ku = (e) => (t, n) => {
        let r = u(xu),
          i = u(fs),
          a = () => ir(e, t, r, i);
        return n ? a() : E(a);
      }),
      (Au = (e) => e.replace(/([a-z])([A-Z])/gu, `$1-$2`).toLowerCase()),
      (ju = `framerAppearId`),
      (Mu = `data-` + Au(ju)),
      (Nu = w({})),
      (Pu = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} })),
      (Fu = { offset: `stroke-dashoffset`, array: `stroke-dasharray` }),
      (Iu = { offset: `strokeDashoffset`, array: `strokeDasharray` }),
      (Lu = () => ({ ...Pu(), attrs: {} })),
      (Ru = (e) => typeof e == `string` && e.toLowerCase() === `svg`),
      (zu = [
        `animate`,
        `circle`,
        `defs`,
        `desc`,
        `ellipse`,
        `g`,
        `image`,
        `line`,
        `filter`,
        `marker`,
        `mask`,
        `metadata`,
        `path`,
        `pattern`,
        `polygon`,
        `polyline`,
        `rect`,
        `stop`,
        `switch`,
        `symbol`,
        `svg`,
        `text`,
        `tspan`,
        `use`,
        `view`,
      ]),
      (Bu = ku({ scrapeMotionValuesFromProps: br, createRenderState: Pu })),
      (Vu = ku({ scrapeMotionValuesFromProps: xr, createRenderState: Lu })),
      (Hu = Symbol.for(`motionComponentSymbol`)),
      (Uu = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 })),
      (Wu = () => ({ x: Uu(), y: Uu() })),
      (Gu = () => ({ min: 0, max: 0 })),
      (Q = () => ({ x: Gu(), y: Gu() })),
      (Ku = new WeakMap()),
      (qu = { current: null }),
      (Ju = { current: !1 }),
      (Yu = [
        `AnimationStart`,
        `AnimationComplete`,
        `Update`,
        `BeforeLayoutMeasure`,
        `LayoutMeasure`,
        `LayoutAnimationStart`,
        `LayoutAnimationComplete`,
      ]),
      (Xu = class {
        scrapeMotionValuesFromProps(e, t, n) {
          return {};
        }
        constructor(
          {
            parent: e,
            props: t,
            presenceContext: n,
            reducedMotionConfig: r,
            blockInitialAnimation: i,
            visualState: a,
          },
          o = {}
        ) {
          ((this.current = null),
            (this.children = new Set()),
            (this.isVariantNode = !1),
            (this.isControllingVariants = !1),
            (this.shouldReduceMotion = null),
            (this.values = new Map()),
            (this.KeyframeResolver = al),
            (this.features = {}),
            (this.valueSubscriptions = new Map()),
            (this.prevMotionValues = {}),
            (this.events = {}),
            (this.propEventSubscriptions = {}),
            (this.notifyUpdate = () => this.notify(`Update`, this.latestValues)),
            (this.render = () => {
              this.current &&
                (this.triggerBuild(),
                this.renderInstance(
                  this.current,
                  this.renderState,
                  this.props.style,
                  this.projection
                ));
            }),
            (this.renderScheduledAt = 0),
            (this.scheduleRender = () => {
              let e = B.now();
              this.renderScheduledAt < e &&
                ((this.renderScheduledAt = e), L.render(this.render, !1, !0));
            }));
          let { latestValues: s, renderState: c } = a;
          ((this.latestValues = s),
            (this.baseTarget = { ...s }),
            (this.initialValues = t.initial ? { ...s } : {}),
            (this.renderState = c),
            (this.parent = e),
            (this.props = t),
            (this.presenceContext = n),
            (this.depth = e ? e.depth + 1 : 0),
            (this.reducedMotionConfig = r),
            (this.options = o),
            (this.blockInitialAnimation = !!i),
            (this.isControllingVariants = er(t)),
            (this.isVariantNode = tr(t)),
            this.isVariantNode && (this.variantChildren = new Set()),
            (this.manuallyAnimateOnMount = !!(e && e.current)));
          let { willChange: l, ...u } = this.scrapeMotionValuesFromProps(t, {}, this);
          for (let e in u) {
            let t = u[e];
            s[e] !== void 0 && X(t) && t.set(s[e]);
          }
        }
        mount(e) {
          ((this.current = e),
            Ku.set(e, this),
            this.projection && !this.projection.instance && this.projection.mount(e),
            this.parent &&
              this.isVariantNode &&
              !this.isControllingVariants &&
              (this.removeFromVariantTree = this.parent.addVariantChild(this)),
            this.values.forEach((e, t) => this.bindToMotionValue(t, e)),
            Ju.current || Mr(),
            (this.shouldReduceMotion =
              this.reducedMotionConfig === `never`
                ? !1
                : this.reducedMotionConfig === `always`
                  ? !0
                  : qu.current),
            this.parent?.addChild(this),
            this.update(this.props, this.presenceContext));
        }
        unmount() {
          for (let e in (this.projection && this.projection.unmount(),
          R(this.notifyUpdate),
          R(this.render),
          this.valueSubscriptions.forEach((e) => e()),
          this.valueSubscriptions.clear(),
          this.removeFromVariantTree && this.removeFromVariantTree(),
          this.parent?.removeChild(this),
          this.events))
            this.events[e].clear();
          for (let e in this.features) {
            let t = this.features[e];
            t && (t.unmount(), (t.isMounted = !1));
          }
          this.current = null;
        }
        addChild(e) {
          (this.children.add(e),
            (this.enteringChildren ??= new Set()),
            this.enteringChildren.add(e));
        }
        removeChild(e) {
          (this.children.delete(e), this.enteringChildren && this.enteringChildren.delete(e));
        }
        bindToMotionValue(e, t) {
          this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)();
          let n = Zc.has(e);
          n && this.onBindTransform && this.onBindTransform();
          let r = t.on(`change`, (t) => {
              ((this.latestValues[e] = t),
                this.props.onUpdate && L.preRender(this.notifyUpdate),
                n && this.projection && (this.projection.isTransformDirty = !0),
                this.scheduleRender());
            }),
            i;
          (o.MotionCheckAppearSync && (i = o.MotionCheckAppearSync(this, e, t)),
            this.valueSubscriptions.set(e, () => {
              (r(), i && i(), t.owner && t.stop());
            }));
        }
        sortNodePosition(e) {
          return !this.current || !this.sortInstanceNodePosition || this.type !== e.type
            ? 0
            : this.sortInstanceNodePosition(this.current, e.current);
        }
        updateFeatures() {
          let e = `animation`;
          for (e in vu) {
            let t = vu[e];
            if (!t) continue;
            let { isEnabled: n, Feature: r } = t;
            if (
              (!this.features[e] && r && n(this.props) && (this.features[e] = new r(this)),
              this.features[e])
            ) {
              let t = this.features[e];
              t.isMounted ? t.update() : (t.mount(), (t.isMounted = !0));
            }
          }
        }
        triggerBuild() {
          this.build(this.renderState, this.latestValues, this.props);
        }
        measureViewportBox() {
          return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Q();
        }
        getStaticValue(e) {
          return this.latestValues[e];
        }
        setStaticValue(e, t) {
          this.latestValues[e] = t;
        }
        update(e, t) {
          ((e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(),
            (this.prevProps = this.props),
            (this.props = e),
            (this.prevPresenceContext = this.presenceContext),
            (this.presenceContext = t));
          for (let t = 0; t < Yu.length; t++) {
            let n = Yu[t];
            this.propEventSubscriptions[n] &&
              (this.propEventSubscriptions[n](), delete this.propEventSubscriptions[n]);
            let r = e[`on` + n];
            r && (this.propEventSubscriptions[n] = this.on(n, r));
          }
          ((this.prevMotionValues = Nr(
            this,
            this.scrapeMotionValuesFromProps(e, this.prevProps, this),
            this.prevMotionValues
          )),
            this.handleChildMotionValue && this.handleChildMotionValue());
        }
        getProps() {
          return this.props;
        }
        getVariant(e) {
          return this.props.variants ? this.props.variants[e] : void 0;
        }
        getDefaultTransition() {
          return this.props.transition;
        }
        getTransformPagePoint() {
          return this.props.transformPagePoint;
        }
        getClosestVariantNode() {
          return this.isVariantNode
            ? this
            : this.parent
              ? this.parent.getClosestVariantNode()
              : void 0;
        }
        addVariantChild(e) {
          let t = this.getClosestVariantNode();
          if (t)
            return (
              t.variantChildren && t.variantChildren.add(e),
              () => t.variantChildren.delete(e)
            );
        }
        addValue(e, t) {
          let n = this.values.get(e);
          t !== n &&
            (n && this.removeValue(e),
            this.bindToMotionValue(e, t),
            this.values.set(e, t),
            (this.latestValues[e] = t.get()));
        }
        removeValue(e) {
          this.values.delete(e);
          let t = this.valueSubscriptions.get(e);
          (t && (t(), this.valueSubscriptions.delete(e)),
            delete this.latestValues[e],
            this.removeValueFromRenderState(e, this.renderState));
        }
        hasValue(e) {
          return this.values.has(e);
        }
        getValue(e, t) {
          if (this.props.values && this.props.values[e]) return this.props.values[e];
          let n = this.values.get(e);
          return (
            n === void 0 &&
              t !== void 0 &&
              ((n = T(t === null ? void 0 : t, { owner: this })), this.addValue(e, n)),
            n
          );
        }
        readValue(e, t) {
          let n =
            this.latestValues[e] !== void 0 || !this.current
              ? this.latestValues[e]
              : (this.getBaseTargetFromProps(this.props, e) ??
                this.readValueFromInstance(this.current, e, this.options));
          return (
            n != null &&
              (typeof n == `string` && (ms(n) || hs(n))
                ? (n = parseFloat(n))
                : !ou(n) && G.test(t) && (n = $t(e, t)),
              this.setBaseTarget(e, X(n) ? n.get() : n)),
            X(n) ? n.get() : n
          );
        }
        setBaseTarget(e, t) {
          this.baseTarget[e] = t;
        }
        getBaseTarget(e) {
          let { initial: t } = this.props,
            n;
          if (typeof t == `string` || typeof t == `object`) {
            let r = rr(this.props, t, this.presenceContext?.custom);
            r && (n = r[e]);
          }
          if (t && n !== void 0) return n;
          let r = this.getBaseTargetFromProps(this.props, e);
          return r !== void 0 && !X(r)
            ? r
            : this.initialValues[e] !== void 0 && n === void 0
              ? void 0
              : this.baseTarget[e];
        }
        on(e, t) {
          return (this.events[e] || (this.events[e] = new ys()), this.events[e].add(t));
        }
        notify(e, ...t) {
          this.events[e] && this.events[e].notify(...t);
        }
        scheduleRenderMicrotask() {
          Gl.render(this.render);
        }
      }),
      (Zu = (e) => Array.isArray(e)),
      (Qu = (e) => e !== null),
      ($u = { type: `spring`, stiffness: 500, damping: 25, restSpeed: 10 }),
      (ed = (e) => ({
        type: `spring`,
        stiffness: 550,
        damping: e === 0 ? 2 * Math.sqrt(550) : 30,
        restSpeed: 10,
      })),
      (td = { type: `keyframes`, duration: 0.8 }),
      (nd = { type: `keyframes`, ease: [0.25, 0.1, 0.35, 1], duration: 0.3 }),
      (rd = (e, { keyframes: t }) =>
        t.length > 2 ? td : Zc.has(e) ? (e.startsWith(`scale`) ? ed(t[1]) : $u) : nd),
      (id =
        (e, t, n, r = {}, i, a) =>
        (o) => {
          let s = Zt(r, e) || {},
            c = s.delay || r.delay || 0,
            { elapsed: l = 0 } = r;
          l -= P(c);
          let u = {
            keyframes: Array.isArray(n) ? n : [null, n],
            ease: `easeOut`,
            velocity: t.getVelocity(),
            ...s,
            delay: -l,
            onUpdate: (e) => {
              (t.set(e), s.onUpdate && s.onUpdate(e));
            },
            onComplete: () => {
              (o(), s.onComplete && s.onComplete());
            },
            name: e,
            motionValue: t,
            element: a ? void 0 : i,
          };
          (Hr(s) || Object.assign(u, rd(e, u)),
            (u.duration &&= P(u.duration)),
            (u.repeatDelay &&= P(u.repeatDelay)),
            u.from !== void 0 && (u.keyframes[0] = u.from));
          let d = !1;
          if (
            ((u.type === !1 || (u.duration === 0 && !u.repeatDelay)) &&
              (Wt(u), u.delay === 0 && (d = !0)),
            (M.instantAnimations || M.skipAnimations) && ((d = !0), Wt(u), (u.delay = 0)),
            (u.allowFlatten = !s.type && !s.ease),
            d && !a && t.get() !== void 0)
          ) {
            let e = Vr(u.keyframes, s);
            if (e !== void 0) {
              L.update(() => {
                (u.onUpdate(e), u.onComplete());
              });
              return;
            }
          }
          return s.isSync ? new Bc(u) : new bl(u);
        }),
      (ad = Ou.length),
      (od = [...Du].reverse()),
      (sd = Du.length),
      ($ = class {
        constructor(e) {
          ((this.isMounted = !1), (this.node = e));
        }
        update() {}
      }),
      (cd = class extends $ {
        constructor(e) {
          (super(e), (e.animationState ||= Qr(e)));
        }
        updateAnimationControlsSubscription() {
          let { animate: e } = this.node.getProps();
          Qn(e) && (this.unmountControls = e.subscribe(this.node));
        }
        mount() {
          this.updateAnimationControlsSubscription();
        }
        update() {
          let { animate: e } = this.node.getProps(),
            { animate: t } = this.node.prevProps || {};
          e !== t && this.updateAnimationControlsSubscription();
        }
        unmount() {
          (this.node.animationState.reset(), this.unmountControls?.());
        }
      }),
      (ld = 0),
      (ud = class extends $ {
        constructor() {
          (super(...arguments), (this.id = ld++));
        }
        update() {
          if (!this.node.presenceContext) return;
          let { isPresent: e, onExitComplete: t } = this.node.presenceContext,
            { isPresent: n } = this.node.prevPresenceContext || {};
          if (!this.node.animationState || e === n) return;
          let r = this.node.animationState.setActive(`exit`, !e);
          t &&
            !e &&
            r.then(() => {
              t(this.id);
            });
        }
        mount() {
          let { register: e, onExitComplete: t } = this.node.presenceContext || {};
          (t && t(this.id), e && (this.unmount = e(this.id)));
        }
        unmount() {}
      }),
      (dd = { animation: { Feature: cd }, exit: { Feature: ud } }),
      (fd = (e) => (t) => Jl(t) && e(t, ni(t))),
      (pd = 1e-4),
      (md = 1 - pd),
      (hd = 1 + pd),
      (gd = 0.01),
      (_d = 0 - gd),
      (vd = 0 + gd),
      (yd = (e, t) => Math.abs(e - t)),
      (bd = 0.999999999999),
      (xd = 1.0000000000001),
      (Sd = class extends Xu {
        constructor() {
          (super(...arguments), (this.KeyframeResolver = Rl));
        }
        sortInstanceNodePosition(e, t) {
          return e.compareDocumentPosition(t) & 2 ? 1 : -1;
        }
        getBaseTargetFromProps(e, t) {
          return e.style ? e.style[t] : void 0;
        }
        removeValueFromRenderState(e, { vars: t, style: n }) {
          (delete t[e], delete n[e]);
        }
        handleChildMotionValue() {
          this.childSubscription && (this.childSubscription(), delete this.childSubscription);
          let { children: e } = this.props;
          X(e) &&
            (this.childSubscription = e.on(`change`, (e) => {
              this.current && (this.current.textContent = `${e}`);
            }));
        }
      }),
      (Cd = class extends Sd {
        constructor() {
          (super(...arguments), (this.type = `html`), (this.renderInstance = Mi));
        }
        readValueFromInstance(e, t) {
          if (Zc.has(t)) return this.projection?.isProjecting ? kt(t) : Yc(e, t);
          {
            let n = Ni(e),
              r = (qs(t) ? n.getPropertyValue(t) : n[t]) || 0;
            return typeof r == `string` ? r.trim() : r;
          }
        }
        measureInstanceViewportBox(e, { transformPagePoint: t }) {
          return Ai(e, t);
        }
        build(e, t, n) {
          ur(e, t, n.transformTemplate);
        }
        scrapeMotionValuesFromProps(e, t, n) {
          return br(e, t, n);
        }
      }),
      (wd = new Set([
        `baseFrequency`,
        `diffuseConstant`,
        `kernelMatrix`,
        `kernelUnitLength`,
        `keySplines`,
        `keyTimes`,
        `limitingConeAngle`,
        `markerHeight`,
        `markerWidth`,
        `numOctaves`,
        `targetX`,
        `targetY`,
        `surfaceScale`,
        `specularConstant`,
        `specularExponent`,
        `stdDeviation`,
        `tableValues`,
        `viewBox`,
        `gradientTransform`,
        `pathLength`,
        `startOffset`,
        `textLength`,
        `lengthAdjust`,
      ])),
      (Td = class extends Sd {
        constructor() {
          (super(...arguments),
            (this.type = `svg`),
            (this.isSVGTag = !1),
            (this.measureInstanceViewportBox = Q));
        }
        getBaseTargetFromProps(e, t) {
          return e[t];
        }
        readValueFromInstance(e, t) {
          if (Zc.has(t)) {
            let e = Il(t);
            return (e && e.default) || 0;
          }
          return ((t = wd.has(t) ? t : Au(t)), e.getAttribute(t));
        }
        scrapeMotionValuesFromProps(e, t, n) {
          return xr(e, t, n);
        }
        build(e, t, n) {
          gr(e, t, this.isSVGTag, n.transformTemplate, n.style);
        }
        renderInstance(e, t, n, r) {
          Pi(e, t, n, r);
        }
        mount(e) {
          ((this.isSVGTag = Ru(e.tagName)), super.mount(e));
        }
      }),
      (Ed = (e, t) => (vr(e) ? new Td(t) : new Cd(t, { allowProjection: e !== c }))),
      (Dd = ({ current: e }) => (e ? e.ownerDocument.defaultView : null)),
      (Od = class {
        constructor(
          e,
          t,
          {
            transformPagePoint: n,
            contextWindow: r = o,
            dragSnapToOrigin: i = !1,
            distanceThreshold: a = 3,
          } = {}
        ) {
          if (
            ((this.startEvent = null),
            (this.lastMoveEvent = null),
            (this.lastMoveEventInfo = null),
            (this.handlers = {}),
            (this.contextWindow = o),
            (this.updatePoint = () => {
              if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
              let e = Li(this.lastMoveEventInfo, this.history),
                t = this.startEvent !== null,
                n = fi(e.offset, { x: 0, y: 0 }) >= this.distanceThreshold;
              if (!t && !n) return;
              let { point: r } = e,
                { timestamp: i } = z;
              this.history.push({ ...r, timestamp: i });
              let { onStart: a, onMove: o } = this.handlers;
              (t || (a && a(this.lastMoveEvent, e), (this.startEvent = this.lastMoveEvent)),
                o && o(this.lastMoveEvent, e));
            }),
            (this.handlePointerMove = (e, t) => {
              ((this.lastMoveEvent = e),
                (this.lastMoveEventInfo = Fi(t, this.transformPagePoint)),
                L.update(this.updatePoint, !0));
            }),
            (this.handlePointerUp = (e, t) => {
              this.end();
              let { onEnd: n, onSessionEnd: r, resumeAnimation: i } = this.handlers;
              if (
                (this.dragSnapToOrigin && i && i(), !(this.lastMoveEvent && this.lastMoveEventInfo))
              )
                return;
              let a = Li(
                e.type === `pointercancel`
                  ? this.lastMoveEventInfo
                  : Fi(t, this.transformPagePoint),
                this.history
              );
              (this.startEvent && n && n(e, a), r && r(e, a));
            }),
            !Jl(e))
          )
            return;
          ((this.dragSnapToOrigin = i),
            (this.handlers = t),
            (this.transformPagePoint = n),
            (this.distanceThreshold = a),
            (this.contextWindow = r || o));
          let s = Fi(ni(e), this.transformPagePoint),
            { point: c } = s,
            { timestamp: l } = z;
          this.history = [{ ...c, timestamp: l }];
          let { onSessionStart: u } = t;
          (u && u(e, Li(s, this.history)),
            (this.removeListeners = _s(
              ii(this.contextWindow, `pointermove`, this.handlePointerMove),
              ii(this.contextWindow, `pointerup`, this.handlePointerUp),
              ii(this.contextWindow, `pointercancel`, this.handlePointerUp)
            )));
        }
        updateHandlers(e) {
          this.handlers = e;
        }
        end() {
          (this.removeListeners && this.removeListeners(), R(this.updatePoint));
        }
      }),
      (kd = 0.35),
      (Ad = new WeakMap()),
      (jd = class {
        constructor(e) {
          ((this.openDragLock = null),
            (this.isDragging = !1),
            (this.currentDirection = null),
            (this.originPoint = { x: 0, y: 0 }),
            (this.constraints = !1),
            (this.hasMutatedConstraints = !1),
            (this.elastic = Q()),
            (this.latestPointerEvent = null),
            (this.latestPanInfo = null),
            (this.visualElement = e));
        }
        start(e, { snapToCursor: t = !1, distanceThreshold: n } = {}) {
          let { presenceContext: r } = this.visualElement;
          if (r && r.isPresent === !1) return;
          let i = (e) => {
              let { dragSnapToOrigin: n } = this.getProps();
              (n ? this.pauseAnimation() : this.stopAnimation(),
                t && this.snapToCursor(ni(e).point));
            },
            a = (e, t) => {
              let { drag: n, dragPropagation: r, onDragStart: i } = this.getProps();
              if (
                n &&
                !r &&
                (this.openDragLock && this.openDragLock(),
                (this.openDragLock = on(n)),
                !this.openDragLock)
              )
                return;
              ((this.latestPointerEvent = e),
                (this.latestPanInfo = t),
                (this.isDragging = !0),
                (this.currentDirection = null),
                this.resolveConstraints(),
                this.visualElement.projection &&
                  ((this.visualElement.projection.isAnimationBlocked = !0),
                  (this.visualElement.projection.target = void 0)),
                O((e) => {
                  let t = this.getAxisMotionValue(e).get() || 0;
                  if (H.test(t)) {
                    let { projection: n } = this.visualElement;
                    if (n && n.layout) {
                      let r = n.layout.layoutBox[e];
                      r && (t = D(r) * (parseFloat(t) / 100));
                    }
                  }
                  this.originPoint[e] = t;
                }),
                i && L.postRender(() => i(e, t)),
                zr(this.visualElement, `transform`));
              let { animationState: a } = this.visualElement;
              a && a.setActive(`whileDrag`, !0);
            },
            o = (e, t) => {
              ((this.latestPointerEvent = e), (this.latestPanInfo = t));
              let {
                dragPropagation: n,
                dragDirectionLock: r,
                onDirectionLock: i,
                onDrag: a,
              } = this.getProps();
              if (!n && !this.openDragLock) return;
              let { offset: o } = t;
              if (r && this.currentDirection === null) {
                ((this.currentDirection = Qi(o)),
                  this.currentDirection !== null && i && i(this.currentDirection));
                return;
              }
              (this.updateAxis(`x`, t.point, o),
                this.updateAxis(`y`, t.point, o),
                this.visualElement.render(),
                a && a(e, t));
            },
            s = (e, t) => {
              ((this.latestPointerEvent = e),
                (this.latestPanInfo = t),
                this.stop(e, t),
                (this.latestPointerEvent = null),
                (this.latestPanInfo = null));
            },
            c = () =>
              O(
                (e) =>
                  this.getAnimationState(e) === `paused` &&
                  this.getAxisMotionValue(e).animation?.play()
              ),
            { dragSnapToOrigin: l } = this.getProps();
          this.panSession = new Od(
            e,
            { onSessionStart: i, onStart: a, onMove: o, onSessionEnd: s, resumeAnimation: c },
            {
              transformPagePoint: this.visualElement.getTransformPagePoint(),
              dragSnapToOrigin: l,
              distanceThreshold: n,
              contextWindow: Dd(this.visualElement),
            }
          );
        }
        stop(e, t) {
          let n = e || this.latestPointerEvent,
            r = t || this.latestPanInfo,
            i = this.isDragging;
          if ((this.cancel(), !i || !r || !n)) return;
          let { velocity: a } = r;
          this.startAnimation(a);
          let { onDragEnd: o } = this.getProps();
          o && L.postRender(() => o(n, r));
        }
        cancel() {
          this.isDragging = !1;
          let { projection: e, animationState: t } = this.visualElement;
          (e && (e.isAnimationBlocked = !1),
            this.panSession && this.panSession.end(),
            (this.panSession = void 0));
          let { dragPropagation: n } = this.getProps();
          (!n && this.openDragLock && (this.openDragLock(), (this.openDragLock = null)),
            t && t.setActive(`whileDrag`, !1));
        }
        updateAxis(e, t, n) {
          let { drag: r } = this.getProps();
          if (!n || !Zi(e, r, this.currentDirection)) return;
          let i = this.getAxisMotionValue(e),
            a = this.originPoint[e] + n[e];
          (this.constraints &&
            this.constraints[e] &&
            (a = Vi(a, this.constraints[e], this.elastic[e])),
            i.set(a));
        }
        resolveConstraints() {
          let { dragConstraints: e, dragElastic: t } = this.getProps(),
            n =
              this.visualElement.projection && !this.visualElement.projection.layout
                ? this.visualElement.projection.measure(!1)
                : this.visualElement.projection?.layout,
            r = this.constraints;
          (e && Sr(e)
            ? (this.constraints ||= this.resolveRefConstraints())
            : e && n
              ? (this.constraints = Ui(n.layoutBox, e))
              : (this.constraints = !1),
            (this.elastic = Ji(t)),
            r !== this.constraints &&
              n &&
              this.constraints &&
              !this.hasMutatedConstraints &&
              O((e) => {
                this.constraints !== !1 &&
                  this.getAxisMotionValue(e) &&
                  (this.constraints[e] = qi(n.layoutBox[e], this.constraints[e]));
              }));
        }
        resolveRefConstraints() {
          let { dragConstraints: e, onMeasureDragConstraints: t } = this.getProps();
          if (!e || !Sr(e)) return !1;
          let n = e.current;
          j(
            n !== null,
            "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.",
            `drag-constraints-ref`
          );
          let { projection: r } = this.visualElement;
          if (!r || !r.layout) return !1;
          let i = ji(n, r.root, this.visualElement.getTransformPagePoint()),
            a = Gi(r.layout.layoutBox, i);
          if (t) {
            let e = t(hi(a));
            ((this.hasMutatedConstraints = !!e), e && (a = mi(e)));
          }
          return a;
        }
        startAnimation(e) {
          let {
              drag: t,
              dragMomentum: n,
              dragElastic: r,
              dragTransition: i,
              dragSnapToOrigin: a,
              onDragTransitionEnd: o,
            } = this.getProps(),
            s = this.constraints || {},
            c = O((o) => {
              if (!Zi(o, t, this.currentDirection)) return;
              let c = (s && s[o]) || {};
              a && (c = { min: 0, max: 0 });
              let l = r ? 200 : 1e6,
                u = r ? 40 : 1e7,
                d = {
                  type: `inertia`,
                  velocity: n ? e[o] : 0,
                  bounceStiffness: l,
                  bounceDamping: u,
                  timeConstant: 750,
                  restDelta: 1,
                  restSpeed: 10,
                  ...i,
                  ...c,
                };
              return this.startAxisValueAnimation(o, d);
            });
          return Promise.all(c).then(o);
        }
        startAxisValueAnimation(e, t) {
          let n = this.getAxisMotionValue(e);
          return (zr(this.visualElement, e), n.start(id(e, n, 0, t, this.visualElement, !1)));
        }
        stopAnimation() {
          O((e) => this.getAxisMotionValue(e).stop());
        }
        pauseAnimation() {
          O((e) => this.getAxisMotionValue(e).animation?.pause());
        }
        getAnimationState(e) {
          return this.getAxisMotionValue(e).animation?.state;
        }
        getAxisMotionValue(e) {
          let t = `_drag${e.toUpperCase()}`,
            n = this.visualElement.getProps();
          return n[t] || this.visualElement.getValue(e, (n.initial ? n.initial[e] : void 0) || 0);
        }
        snapToCursor(e) {
          O((t) => {
            let { drag: n } = this.getProps();
            if (!Zi(t, n, this.currentDirection)) return;
            let { projection: r } = this.visualElement,
              i = this.getAxisMotionValue(t);
            if (r && r.layout) {
              let { min: n, max: a } = r.layout.layoutBox[t];
              i.set(e[t] - K(n, a, 0.5));
            }
          });
        }
        scalePositionWithinConstraints() {
          if (!this.visualElement.current) return;
          let { drag: e, dragConstraints: t } = this.getProps(),
            { projection: n } = this.visualElement;
          if (!Sr(t) || !n || !this.constraints) return;
          this.stopAnimation();
          let r = { x: 0, y: 0 };
          O((e) => {
            let t = this.getAxisMotionValue(e);
            if (t && this.constraints !== !1) {
              let n = t.get();
              r[e] = Ki({ min: n, max: n }, this.constraints[e]);
            }
          });
          let { transformTemplate: i } = this.visualElement.getProps();
          ((this.visualElement.current.style.transform = i ? i({}, ``) : `none`),
            n.root && n.root.updateScroll(),
            n.updateLayout(),
            this.resolveConstraints(),
            O((t) => {
              if (!Zi(t, e, null)) return;
              let n = this.getAxisMotionValue(t),
                { min: i, max: a } = this.constraints[t];
              n.set(K(i, a, r[t]));
            }));
        }
        addListeners() {
          if (!this.visualElement.current) return;
          Ad.set(this.visualElement, this);
          let e = this.visualElement.current,
            t = ii(e, `pointerdown`, (e) => {
              let { drag: t, dragListener: n = !0 } = this.getProps();
              t && n && this.start(e);
            }),
            n = () => {
              let { dragConstraints: e } = this.getProps();
              Sr(e) && e.current && (this.constraints = this.resolveRefConstraints());
            },
            { projection: r } = this.visualElement,
            i = r.addEventListener(`measure`, n);
          (r && !r.layout && (r.root && r.root.updateScroll(), r.updateLayout()), L.read(n));
          let a = ri(o, `resize`, () => this.scalePositionWithinConstraints()),
            s = r.addEventListener(`didUpdate`, ({ delta: e, hasLayoutChanged: t }) => {
              this.isDragging &&
                t &&
                (O((t) => {
                  let n = this.getAxisMotionValue(t);
                  n && ((this.originPoint[t] += e[t].translate), n.set(n.get() + e[t].translate));
                }),
                this.visualElement.render());
            });
          return () => {
            (a(), t(), i(), s && s());
          };
        }
        getProps() {
          let e = this.visualElement.getProps(),
            {
              drag: t = !1,
              dragDirectionLock: n = !1,
              dragPropagation: r = !1,
              dragConstraints: i = !1,
              dragElastic: a = kd,
              dragMomentum: o = !0,
            } = e;
          return {
            ...e,
            drag: t,
            dragDirectionLock: n,
            dragPropagation: r,
            dragConstraints: i,
            dragElastic: a,
            dragMomentum: o,
          };
        }
      }),
      (Md = class extends $ {
        constructor(e) {
          (super(e),
            (this.removeGroupControls = N),
            (this.removeListeners = N),
            (this.controls = new jd(e)));
        }
        mount() {
          let { dragControls: e } = this.node.getProps();
          (e && (this.removeGroupControls = e.subscribe(this.controls)),
            (this.removeListeners = this.controls.addListeners() || N));
        }
        unmount() {
          (this.removeGroupControls(), this.removeListeners());
        }
      }),
      (Nd = (e) => (t, n) => {
        e && L.postRender(() => e(t, n));
      }),
      (Pd = class extends $ {
        constructor() {
          (super(...arguments), (this.removePointerDownListener = N));
        }
        onPointerDown(e) {
          this.session = new Od(e, this.createPanHandlers(), {
            transformPagePoint: this.node.getTransformPagePoint(),
            contextWindow: Dd(this.node),
          });
        }
        createPanHandlers() {
          let { onPanSessionStart: e, onPanStart: t, onPan: n, onPanEnd: r } = this.node.getProps();
          return {
            onSessionStart: Nd(e),
            onStart: Nd(t),
            onMove: n,
            onEnd: (e, t) => {
              (delete this.session, r && L.postRender(() => r(e, t)));
            },
          };
        }
        mount() {
          this.removePointerDownListener = ii(this.node.current, `pointerdown`, (e) =>
            this.onPointerDown(e)
          );
        }
        update() {
          this.session && this.session.updateHandlers(this.createPanHandlers());
        }
        unmount() {
          (this.removePointerDownListener(), this.session && this.session.end());
        }
      }),
      (Fd = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }),
      (Id = !1),
      (Ld = class extends v {
        componentDidMount() {
          let { visualElement: e, layoutGroup: t, switchLayoutGroup: n, layoutId: r } = this.props,
            { projection: i } = e;
          (i &&
            (t.group && t.group.add(i),
            n && n.register && r && n.register(i),
            Id && i.root.didUpdate(),
            i.addEventListener(`animationComplete`, () => {
              this.safeToRemove();
            }),
            i.setOptions({ ...i.options, onExitComplete: () => this.safeToRemove() })),
            (Fd.hasEverUpdated = !0));
        }
        getSnapshotBeforeUpdate(e) {
          let { layoutDependency: t, visualElement: n, drag: r, isPresent: i } = this.props,
            { projection: a } = n;
          return a
            ? ((a.isPresent = i),
              (Id = !0),
              r || e.layoutDependency !== t || t === void 0 || e.isPresent !== i
                ? a.willUpdate()
                : this.safeToRemove(),
              e.isPresent !== i &&
                (i
                  ? a.promote()
                  : a.relegate() ||
                    L.postRender(() => {
                      let e = a.getStack();
                      (!e || !e.members.length) && this.safeToRemove();
                    })),
              null)
            : null;
        }
        componentDidUpdate() {
          let { projection: e } = this.props.visualElement;
          e &&
            (e.root.didUpdate(),
            Gl.postRender(() => {
              !e.currentAnimation && e.isLead() && this.safeToRemove();
            }));
        }
        componentWillUnmount() {
          let { visualElement: e, layoutGroup: t, switchLayoutGroup: n } = this.props,
            { projection: r } = e;
          ((Id = !0),
            r &&
              (r.scheduleCheckAfterUnmount(),
              t && t.group && t.group.remove(r),
              n && n.deregister && n.deregister(r)));
        }
        safeToRemove() {
          let { safeToRemove: e } = this.props;
          e && e();
        }
        render() {
          return null;
        }
      }),
      (Rd = (e, t) => e.depth - t.depth),
      (zd = class {
        constructor() {
          ((this.children = []), (this.isDirty = !1));
        }
        add(e) {
          (Me(this.children, e), (this.isDirty = !0));
        }
        remove(e) {
          (Ne(this.children, e), (this.isDirty = !0));
        }
        forEach(e) {
          (this.isDirty && this.children.sort(Rd), (this.isDirty = !1), this.children.forEach(e));
        }
      }),
      (Bd = [`TopLeft`, `TopRight`, `BottomLeft`, `BottomRight`]),
      (Vd = Bd.length),
      (Hd = (e) => (typeof e == `string` ? parseFloat(e) : e)),
      (Ud = (e) => typeof e == `number` || U.test(e)),
      (Wd = ra(0, 0.5, js)),
      (Gd = ra(0.5, 0.95, N)),
      (Kd = [`x`, `scaleX`, `originX`]),
      (qd = [`y`, `scaleY`, `originY`]),
      (Jd = class {
        constructor() {
          this.members = [];
        }
        add(e) {
          (Me(this.members, e), e.scheduleRender());
        }
        remove(e) {
          if (
            (Ne(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead)
          ) {
            let e = this.members[this.members.length - 1];
            e && this.promote(e);
          }
        }
        relegate(e) {
          let t = this.members.findIndex((t) => e === t);
          if (t === 0) return !1;
          let n;
          for (let e = t; e >= 0; e--) {
            let t = this.members[e];
            if (t.isPresent !== !1) {
              n = t;
              break;
            }
          }
          return n ? (this.promote(n), !0) : !1;
        }
        promote(e, t) {
          let n = this.lead;
          if (e !== n && ((this.prevLead = n), (this.lead = e), e.show(), n)) {
            (n.instance && n.scheduleRender(),
              e.scheduleRender(),
              (e.resumeFrom = n),
              t && (e.resumeFrom.preserveOpacity = !0),
              n.snapshot &&
                ((e.snapshot = n.snapshot),
                (e.snapshot.latestValues = n.animationValues || n.latestValues)),
              e.root && e.root.isUpdating && (e.isLayoutDirty = !0));
            let { crossfade: r } = e.options;
            r === !1 && n.hide();
          }
        }
        exitAnimationComplete() {
          this.members.forEach((e) => {
            let { options: t, resumingFrom: n } = e;
            (t.onExitComplete && t.onExitComplete(),
              n && n.options.onExitComplete && n.options.onExitComplete());
          });
        }
        scheduleRender() {
          this.members.forEach((e) => {
            e.instance && e.scheduleRender(!1);
          });
        }
        removeLeadSnapshot() {
          this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
        }
      }),
      (Yd = { nodes: 0, calculatedTargetDeltas: 0, calculatedProjections: 0 }),
      (Xd = [``, `X`, `Y`, `Z`]),
      (Zd = 1e3),
      (Qd = 0),
      ($d = { duration: 0.45, ease: [0.4, 0, 0.1, 1] }),
      (ef = (e) => m !== void 0 && m.userAgent && m.userAgent.toLowerCase().includes(e)),
      (tf = ef(`applewebkit/`) && !ef(`chrome/`) ? Math.round : N),
      (nf = xa({
        attachResizeListener: (e, t) => ri(e, `resize`, t),
        measureScroll: () => ({
          x: document.documentElement.scrollLeft || document.body.scrollLeft,
          y: document.documentElement.scrollTop || document.body.scrollTop,
        }),
        checkIsScrollRoot: () => !0,
      })),
      (rf = { current: void 0 }),
      (af = xa({
        measureScroll: (e) => ({ x: e.scrollLeft, y: e.scrollTop }),
        defaultParent: () => {
          if (!rf.current) {
            let e = new nf({});
            (e.mount(o), e.setOptions({ layoutScroll: !0 }), (rf.current = e));
          }
          return rf.current;
        },
        resetTransform: (e, t) => {
          e.style.transform = t === void 0 ? `none` : t;
        },
        checkIsScrollRoot: (e) => o.getComputedStyle(e).position === `fixed`,
      })),
      (of = { pan: { Feature: Pd }, drag: { Feature: Md, ProjectionNode: af, MeasureLayout: $i } }),
      (sf = class extends $ {
        mount() {
          let { current: e } = this.node;
          e &&
            (this.unmount = ln(
              e,
              (e, t) => (Ua(this.node, t, `Start`), (e) => Ua(this.node, e, `End`))
            ));
        }
        unmount() {}
      }),
      (cf = class extends $ {
        constructor() {
          (super(...arguments), (this.isActive = !1));
        }
        onFocus() {
          let e = !1;
          try {
            e = this.node.current.matches(`:focus-visible`);
          } catch {
            e = !0;
          }
          !e ||
            !this.node.animationState ||
            (this.node.animationState.setActive(`whileFocus`, !0), (this.isActive = !0));
        }
        onBlur() {
          !this.isActive ||
            !this.node.animationState ||
            (this.node.animationState.setActive(`whileFocus`, !1), (this.isActive = !1));
        }
        mount() {
          this.unmount = _s(
            ri(this.node.current, `focus`, () => this.onFocus()),
            ri(this.node.current, `blur`, () => this.onBlur())
          );
        }
        unmount() {}
      }),
      (lf = class extends $ {
        mount() {
          let { current: e } = this.node;
          e &&
            (this.unmount = mn(
              e,
              (e, t) => (
                Wa(this.node, t, `Start`),
                (e, { success: t }) => Wa(this.node, e, t ? `End` : `Cancel`)
              ),
              { useGlobalTarget: this.node.props.globalTapTarget }
            ));
        }
        unmount() {}
      }),
      (uf = new WeakMap()),
      (df = new WeakMap()),
      (ff = (e) => {
        let t = uf.get(e.target);
        t && t(e);
      }),
      (pf = (e) => {
        e.forEach(ff);
      }),
      (mf = { some: 0, all: 1 }),
      (hf = class extends $ {
        constructor() {
          (super(...arguments), (this.hasEnteredView = !1), (this.isInView = !1));
        }
        startObserver() {
          this.unmount();
          let { viewport: e = {} } = this.node.getProps(),
            { root: t, margin: n, amount: r = `some`, once: i } = e,
            a = {
              root: t ? t.current : void 0,
              rootMargin: n,
              threshold: typeof r == `number` ? r : mf[r],
            };
          return Ka(this.node.current, a, (e) => {
            let { isIntersecting: t } = e;
            if (this.isInView === t || ((this.isInView = t), i && !t && this.hasEnteredView))
              return;
            (t && (this.hasEnteredView = !0),
              this.node.animationState && this.node.animationState.setActive(`whileInView`, t));
            let { onViewportEnter: n, onViewportLeave: r } = this.node.getProps(),
              a = t ? n : r;
            a && a(e);
          });
        }
        mount() {
          this.startObserver();
        }
        update() {
          if (typeof IntersectionObserver > `u`) return;
          let { props: e, prevProps: t } = this.node;
          [`amount`, `margin`, `root`].some(qa(e, t)) && this.startObserver();
        }
        unmount() {}
      }),
      (gf = {
        inView: { Feature: hf },
        tap: { Feature: lf },
        focus: { Feature: cf },
        hover: { Feature: sf },
      }),
      (_f = { layout: { ProjectionNode: af, MeasureLayout: $i } }),
      (vf = jr({ ...dd, ...gf, ...of, ..._f }, Ed)),
      (yf = { renderer: Ed, ...dd, ...gf }),
      { ...yf, ...of, ..._f },
      { ...dd },
      (bf = 50),
      (xf = () => ({
        current: 0,
        offset: [],
        progress: 0,
        scrollLength: 0,
        targetOffset: 0,
        targetLength: 0,
        containerLength: 0,
        velocity: 0,
      })),
      (Sf = () => ({ time: 0, x: xf(), y: xf() })),
      (Cf = { x: { length: `Width`, position: `Left` }, y: { length: `Height`, position: `Top` } }),
      (wf = { start: 0, center: 0.5, end: 1 }),
      (Tf = [0, 0]),
      (Ef = {
        Enter: [
          [0, 1],
          [1, 1],
        ],
        Exit: [
          [0, 0],
          [1, 0],
        ],
        Any: [
          [1, 0],
          [0, 1],
        ],
        All: [
          [0, 0],
          [1, 1],
        ],
      }),
      (Df = { x: 0, y: 0 }),
      (Of = new WeakMap()),
      (kf = new WeakMap()),
      (Af = new WeakMap()),
      (jf = (e) => (e === document.scrollingElement ? o : e)),
      (Mf = new Map()),
      (Nf = () => ({ scrollX: T(0), scrollY: T(0), scrollXProgress: T(0), scrollYProgress: T(0) })),
      (Pf = (e) => (e ? !e.current : !1)),
      (Ff = class extends Wl {
        constructor() {
          (super(...arguments), (this.isEnabled = !1));
        }
        add(e) {
          (Zc.has(e) || zl.has(e)) && ((this.isEnabled = !0), this.update());
        }
        update() {
          this.set(this.isEnabled ? `transform` : `auto`);
        }
      }),
      (If = `easeInOut`),
      (Lf = 20),
      (Rf = (e) => typeof e == `number`),
      (zf = (e) => e.every(Rf)),
      (Bf = class extends Xu {
        constructor() {
          (super(...arguments), (this.type = `object`));
        }
        readValueFromInstance(e, t) {
          if (Bo(t, e)) {
            let n = e[t];
            if (typeof n == `string` || typeof n == `number`) return n;
          }
        }
        getBaseTargetFromProps() {}
        removeValueFromRenderState(e, t) {
          delete t.output[e];
        }
        measureInstanceViewportBox() {
          return Q();
        }
        build(e, t) {
          Object.assign(e.output, t);
        }
        renderInstance(e, { output: t }) {
          Object.assign(e, t);
        }
        sortInstanceNodePosition() {
          return 0;
        }
      }),
      (Vf = qo()),
      (Hf = Jo),
      (Uf = { some: 0, all: 1 }),
      (Wf = () => ({})),
      ku({ scrapeMotionValuesFromProps: Wf, createRenderState: Wf }),
      (Gf = {}),
      me(Gf, { Group: () => qf, Item: () => Jf }),
      (Kf = w(null)),
      (qf = h(is)),
      (Jf = h(cs)));
  }),
  Xf = t(() => {
    Yf();
  });
export {
  Ae as $,
  kn as A,
  So as B,
  T as C,
  gt as D,
  uo as E,
  Zo as F,
  bo as G,
  fo as H,
  ns as I,
  Ce as J,
  Ku as K,
  po as L,
  Hf as M,
  yo as N,
  En as O,
  ts as P,
  De as Q,
  Rn as R,
  vf as S,
  Zn as T,
  vo as U,
  $o as V,
  go as W,
  _e as X,
  xe as Y,
  Oe as Z,
  Yf as _,
  Z as a,
  X as b,
  fs as c,
  Yn as d,
  ke as et,
  Vf as f,
  es as g,
  L as h,
  qn as i,
  je as it,
  Xo as j,
  Dn as k,
  Nu as l,
  R as m,
  uu as n,
  Se as nt,
  M as o,
  Dt as p,
  pe as q,
  hu as r,
  ge as rt,
  Wl as s,
  Xf as t,
  we as tt,
  Ff as u,
  yt as v,
  Mu as w,
  Wn as x,
  Yo as y,
  xo as z,
};
